"use strict";function resolveUploadPath(e,r=[]){process.env.NODE_ENV;const t=[path_1.default.join(process.cwd(),"frontend","public",e),path_1.default.join(process.cwd(),"public",e),path_1.default.join(process.cwd(),"..","frontend","public",e),path_1.default.join(process.cwd(),"..","public",e)],o=[...t,...r];for(const e of o){const r=path_1.default.dirname(e);if(fs_1.default.existsSync(r)){console_1.logger.debug("PATH",`Selected: ${e}`);return e}}const s=t[0];console_1.logger.debug("PATH",`No existing parent found, using default: ${s}`);return s}async function ensureDirectoryExists(e,r=!0){try{await fs_1.default.promises.access(e);console_1.logger.debug("PATH",`Directory exists: ${e}`)}catch(t){if("ENOENT"!==t.code){console_1.logger.error("PATH",`Directory access error: ${e}`,t);throw t}try{console_1.logger.debug("PATH",`Creating directory: ${e}`);await fs_1.default.promises.mkdir(e,{recursive:r});console_1.logger.debug("PATH",`Directory created: ${e}`)}catch(r){console_1.logger.error("PATH",`Failed to create directory: ${e}`,r);throw(0,error_1.createError)({statusCode:500,message:`Failed to create directory: ${r.message}`})}}}async function tryMultiplePaths(e){for(const r of e)try{await ensureDirectoryExists(r);return r}catch(e){console_1.logger.debug("PATH",`Failed to use path ${r}: ${e.message}`);continue}throw(0,error_1.createError)({statusCode:500,message:`Failed to create directory in any of the attempted paths: ${e.join(", ")}`})}var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});exports.resolveUploadPath=resolveUploadPath;exports.ensureDirectoryExists=ensureDirectoryExists;exports.tryMultiplePaths=tryMultiplePaths;const fs_1=__importDefault(require("fs")),path_1=__importDefault(require("path")),console_1=require("@b/utils/console"),error_1=require("@b/utils/error");