"use strict";async function getFiltered({model:e,query:r,where:t,customFilterHandler:s,customStatus:o,sortField:a="createdAt",timestamps:n=!0,paranoid:i=!0,numericFields:l=[],includeModels:d=[],excludeFields:c=[],excludeRecords:p=[],compute:u=[]}){const m=Number(r.page)||1,f=Number(r.perPage)||10,g=(m-1)*f;let h=r.sortOrder||"desc";"string"==typeof h&&(h=decodeURIComponent(h));"string"==typeof a&&(a=decodeURIComponent(a));let y=[];y="string"==typeof a?a.split(",").map(e=>e.trim()).filter(Boolean):Array.isArray(a)?a:[a];let R=[];R="string"==typeof h?h.split(",").map(e=>e.trim()).filter(Boolean):Array.isArray(h)?h:[h];const _=y.map((r,t)=>{const s=R[t]&&"asc"===R[t].toLowerCase()?"ASC":"DESC";if(r.includes(".")){const t=r.split("."),o=[];let a=e;for(let e=0;e<t.length-1;e++){const r=t[e];if(a.associations&&a.associations[r]){const e=a.associations[r];o.push({model:e.target,as:r});a=e.target}else o.push(r)}o.push(t[t.length-1]);o.push(s);return o}return[r,s]}),w=parseFilterParam(r.filter,l),{nestedFilters:b,directFilters:q}=buildNestedFilters(w),x={...t,...s?s(q):{}};p.forEach(e=>{e.model||(x[e.key]={[sequelize_1.Op.ne]:e.value})});null==o||o.forEach(({key:e,true:r,false:t})=>{if(Object.prototype.hasOwnProperty.call(q,e)){const s=q[e];"true"===s?x[e]=r:"false"===s&&(x[e]=t);delete q[e]}});Object.entries(q).forEach(([e,r])=>{if(l.includes(e)&&"object"!=typeof r)x[e]=parseFloat(r)||r;else if("object"==typeof r&&r.operator){const{value:t,operator:s}=r,o=operatorMap[s];x[e]={[o]:t}}else x[e]=r});let E=!r.showDeleted;n&&i?"true"===r.showDeleted?x[sequelize_1.Op.and]={deletedAt:{[sequelize_1.Op.ne]:null}}:x[sequelize_1.Op.and]={deletedAt:null}:E=void 0;const v=adjustIncludeModels(d,p,b),O=u&&u.length>0?{include:u,exclude:c}:{exclude:c},z={where:x,offset:g,limit:f,include:v,distinct:!0,col:"id",attributes:O,order:_,paranoid:E},{count:F,rows:M}=await e.findAndCountAll(z);return{items:M.map(e=>e.get({plain:!0})),pagination:{totalItems:Array.isArray(F)?F.length:F,currentPage:m,perPage:f,totalPages:Math.ceil((Array.isArray(F)?F.length:F)/f)}}}function adjustIncludeModels(e,r,t){return e.map(e=>{const s=r.filter(r=>r.model===e.model),o=t[e.as]||{},a={...e.where,...o,...s.length?{[sequelize_1.Op.and]:s.map(e=>({[e.key]:{[sequelize_1.Op.ne]:e.value}}))}:{}},n=!!(o&&Object.keys(o).length>0)||(e.required||!1),i=e.includeModels?adjustIncludeModels(e.includeModels,r,t):e.include||[];return{...e,where:a,include:i,required:n}})}function parseFilterParam(e,r){const t={};if(!e)return t;let s={};if("string"==typeof e)try{s=JSON.parse(e)}catch(e){console_1.logger.debug("QUERY","Error parsing filter param");return t}Object.entries(s).forEach(([e,s])=>{const o=e.split(".");let a=t;o.slice(0,-1).forEach(e=>{a[e]=a[e]||{};a=a[e]});let n=s;r.includes(o[o.length-1])&&"object"==typeof s&&"startsWith"===s.operator&&(n={operator:"greaterThan",value:parseFloat(s.value)});a[o[o.length-1]]=n});return t}function buildNestedFilters(e){const r={},t={};Object.entries(e).forEach(([e,s])=>{if("boolean"==typeof s||"object"==typeof s&&"operator"in s&&"value"in s)t[e]=s;else{const t=e.split(".");let o=r;for(let e=0;e<t.length-1;e++){const r=t[e];o[r]=o[r]||{};o=o[r]}o[t[t.length-1]]=s}});return{nestedFilters:applyOperatorMapping(r),directFilters:t}}function applyOperatorMapping(e){const r={},t=(e,r)=>{Object.entries(e).forEach(([e,s])=>{if(s&&"object"==typeof s&&s.operator&&operatorMap[s.operator])r[e]={[operatorMap[s.operator]]:s.value};else if(s&&"object"==typeof s&&!s.operator){r[e]={};t(s,r[e])}else r[e]=s})};t(e,r);return r}async function updateStatus(e,r,t,s="status",o="Record",a,n){if(!db_1.models[e])throw(0,error_1.createError)({statusCode:400,message:"Invalid model"});if(!r)throw(0,error_1.createError)({statusCode:400,message:"Missing ID"});if(void 0===t)throw(0,error_1.createError)({statusCode:400,message:"Missing field value"});if(!s)throw(0,error_1.createError)({statusCode:400,message:"Missing field name"});try{const i={};i[s]=t;await db_1.models[e].update(i,{where:{id:r,...n}});const l=e.charAt(0).toUpperCase()+e.slice(1),d=`${o||l+" "+s} updated successfully`;a&&await a(r);return{message:d}}catch(e){console_1.logger.error("QUERY","Error updating status",e);throw(0,error_1.createError)({statusCode:500,message:e.message})}}function resolveIncludes(e){if(e)return e.map(e=>{const{model:r,as:t,attributes:s,includeModels:o,through:a,required:n,paranoid:i}=e,l={model:r,as:t,attributes:null==s?void 0:s.map(e=>Array.isArray(e)?e:[e,e]),required:n};void 0!==i&&(l.paranoid=i);o&&(l.include=resolveIncludes(o));a&&(l.through=a);return l})}async function getRecord(e,r,t,s=[]){if(!r)throw(0,error_1.createError)({statusCode:400,message:"Missing ID"});const o=db_1.models[e];if(!o)throw(0,error_1.createError)({statusCode:404,message:`Model ${e} not found`});const a=resolveIncludes(t),n=await o.findOne({where:{id:r},attributes:{exclude:s},include:a});if(!n)throw(0,error_1.createError)({statusCode:404,message:`Record with ID ${r} not found`});return n.get({plain:!0})}async function getRecords(e,r,t,s=[]){const o=db_1.models[e];if(!o)throw(0,error_1.createError)({statusCode:404,message:`Model ${e} not found`});const a=resolveIncludes(t);try{return(await o.findAll({where:{id:r},attributes:{exclude:s},include:a})).map(e=>e.get({plain:!0}))}catch(r){console_1.logger.error("QUERY",`Error fetching ${e}`,r);throw(0,error_1.createError)({statusCode:500,message:"Server error"})}}async function deleteFile(e){const r=(0,validation_1.sanitizePath)(e),t=path_1.default.join(process.cwd(),"public",r);await promises_1.default.unlink(t)}async function updateRecord(e,r,t,s=!1,o=[],a){const n=db_1.models[e];if(!n)throw(0,error_1.createError)({statusCode:404,message:`Model ${e} not found`});const i=await db_1.sequelize.transaction();try{if(!await n.findByPk(r,{transaction:i}))throw(0,error_1.createError)({statusCode:404,message:`${e} with ID ${r} not found`});await n.update(t,{where:{id:r,...a},transaction:i});for(const e of o){const t=db_1.models[e.model];if(!t){console_1.logger.warn("QUERY",`Related model ${e.model} not found`);continue}const s=await t.findAll({where:{[e.fields.source]:r},transaction:i}),o=new Map(e.data.map(e=>[e,e])),a=s.filter(r=>!o.has(r[e.fields.target]));await Promise.all(a.map(e=>e.destroy({transaction:i})));for(const o of e.data){const a=s.find(r=>r[e.fields.target]===o);a?await a.update(o,{transaction:i}):await t.create({[e.fields.source]:r,[e.fields.target]:o},{transaction:i})}}await i.commit();return s?n.findByPk(r):{message:`${e} updated successfully`}}catch(e){console_1.logger.error("QUERY","Transaction rollback - update failed",e);await i.rollback();throw e}}async function storeRecord({model:e,data:r,relations:t,returnResponse:s=!1}){const o=db_1.models[e];if(!o)throw(0,error_1.createError)({statusCode:404,message:`Model ${e} not found`});const a=await db_1.sequelize.transaction();try{void 0!==r.customFields&&null!==r.customFields||(r.customFields=[]);if(!Array.isArray(r.customFields))throw(0,error_1.createError)({statusCode:400,message:"customFields must be an array"});const n=await o.create(r,{transaction:a});if(t&&Array.isArray(t))for(const e of t){const r=db_1.models[e.model];if(r)if(Array.isArray(e.data))for(const t of e.data)await r.create({[e.fields.source]:n.id,[e.fields.target]:t},{transaction:a});else console_1.logger.warn("QUERY",`Relation data for ${e.model} is not an array`);else console_1.logger.warn("QUERY",`Related model ${e.model} not found`)}await a.commit();return s?{record:n.get({plain:!0}),message:`${e} created successfully`}:{message:`${e} created successfully`}}catch(e){console_1.logger.error("QUERY","Transaction rollback - store failed",e);await a.rollback();throw e}}async function handleSingleDelete({model:e,query:r,where:t={},id:s,preDelete:o=async()=>Promise.resolve(),postDelete:a=async()=>Promise.resolve(),restoreRelated:n=async()=>Promise.resolve()}){if(!db_1.models[e])throw(0,error_1.createError)({statusCode:400,message:"Invalid model"});if(!s)throw(0,error_1.createError)({statusCode:400,message:"Missing ID"});try{const i={...t,id:s},l=e.charAt(0).toUpperCase()+e.slice(1);await o();if(r.restore){await db_1.models[e].restore({where:i});await n();await a();return{message:`${l} restored successfully.`}}if(r.force){await db_1.models[e].destroy({where:i,force:!0});await a();return{message:`${l} deleted permanently.`}}await db_1.models[e].destroy({where:i});await a();return{message:`${l} deleted successfully.`}}catch(e){console_1.logger.error("QUERY","Error in single delete",e);throw(0,error_1.createError)({statusCode:500,message:e.message})}}async function handleBulkDelete({model:e,ids:r,query:t,where:s={},preDelete:o=async()=>Promise.resolve(),postDelete:a=async()=>Promise.resolve(),restoreRelated:n=async()=>Promise.resolve()}){if(!db_1.models[e])throw(0,error_1.createError)({statusCode:400,message:`Invalid model: ${e}`});if(!r||!Array.isArray(r)||0===r.length)throw(0,error_1.createError)({statusCode:400,message:"Missing IDs"});try{const i={...s,id:r},l=e.charAt(0).toUpperCase()+e.slice(1);await o();if(t.restore){await db_1.models[e].restore({where:i});await n();await a();return{message:`${l} records restored successfully.`}}if(t.force){await db_1.models[e].destroy({where:i,force:!0});await a();return{message:`${l} records deleted permanently.`}}await db_1.models[e].destroy({where:i});await a();return{message:`${l} records deleted successfully.`}}catch(e){console_1.logger.error("QUERY","Error in bulk delete",e);throw(0,error_1.createError)({statusCode:500,message:e.message})}}var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});exports.deleteRecordParams=exports.commonBulkDeleteResponses=exports.commonBulkDeleteParams=exports.createRecordResponses=exports.storeRecordResponses=exports.updateRecordResponses=exports.deleteRecordResponses=exports.invalidRequestResponse=exports.serverErrorResponse=exports.notFoundMetadataResponse=exports.unauthorizedResponse=void 0;exports.getFiltered=getFiltered;exports.parseFilterParam=parseFilterParam;exports.updateStatus=updateStatus;exports.getRecord=getRecord;exports.getRecords=getRecords;exports.deleteFile=deleteFile;exports.updateRecord=updateRecord;exports.storeRecord=storeRecord;exports.handleSingleDelete=handleSingleDelete;exports.handleBulkDelete=handleBulkDelete;const promises_1=__importDefault(require("fs/promises")),sequelize_1=require("sequelize"),error_1=require("./error"),db_1=require("@b/db"),path_1=__importDefault(require("path")),validation_1=require("./validation"),console_1=require("@b/utils/console"),operatorMap={equal:sequelize_1.Op.eq,notEqual:sequelize_1.Op.ne,greaterThan:sequelize_1.Op.gt,greaterThanOrEqual:sequelize_1.Op.gte,lessThan:sequelize_1.Op.lt,lessThanOrEqual:sequelize_1.Op.lte,between:sequelize_1.Op.between,notBetween:sequelize_1.Op.notBetween,like:sequelize_1.Op.like,notLike:sequelize_1.Op.notLike,startsWith:sequelize_1.Op.startsWith,endsWith:sequelize_1.Op.endsWith,substring:sequelize_1.Op.substring,regexp:sequelize_1.Op.regexp,notRegexp:sequelize_1.Op.notRegexp,contains:sequelize_1.Op.like};exports.unauthorizedResponse={description:"Unauthorized, admin permission required",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Error message"}}}}}};const notFoundMetadataResponse=e=>({description:`${e} not found`,content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Error message"}}}}}});exports.notFoundMetadataResponse=notFoundMetadataResponse;exports.serverErrorResponse={description:"Internal server error",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Error message"}}}}}};exports.invalidRequestResponse={description:"Invalid request",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Error message"}}}}}};const deleteRecordResponses=e=>({200:{description:`${e} deleted successfully`,content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Confirmation message indicating successful deletion"}}}}}},401:exports.unauthorizedResponse,404:(0,exports.notFoundMetadataResponse)(e),500:exports.serverErrorResponse});exports.deleteRecordResponses=deleteRecordResponses;const updateRecordResponses=e=>({200:{description:`${e} updated successfully`,content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Confirmation message"}}}}}},400:exports.invalidRequestResponse,401:exports.unauthorizedResponse,404:(0,exports.notFoundMetadataResponse)(e),500:exports.serverErrorResponse});exports.updateRecordResponses=updateRecordResponses;const storeRecordResponses=(e,r)=>({200:e,400:exports.invalidRequestResponse,401:exports.unauthorizedResponse,404:(0,exports.notFoundMetadataResponse)(r),500:exports.serverErrorResponse});exports.storeRecordResponses=storeRecordResponses;const createRecordResponses=e=>({200:{description:`${e} created successfully`,content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Confirmation message"}}}}}},400:exports.invalidRequestResponse,401:exports.unauthorizedResponse,500:exports.serverErrorResponse});exports.createRecordResponses=createRecordResponses;const commonBulkDeleteParams=e=>[{name:"restore",in:"query",description:`Restore the ${e} instead of deleting`,required:!1,schema:{type:"boolean"}},{name:"force",in:"query",description:`Delete the ${e} permanently`,required:!1,schema:{type:"boolean"}}];exports.commonBulkDeleteParams=commonBulkDeleteParams;const commonBulkDeleteResponses=e=>({200:{description:`${e} deleted successfully`,content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Confirmation message"}}}}}},400:exports.invalidRequestResponse,401:exports.unauthorizedResponse,404:(0,exports.notFoundMetadataResponse)(e),500:exports.serverErrorResponse});exports.commonBulkDeleteResponses=commonBulkDeleteResponses;const deleteRecordParams=e=>[{index:0,name:"id",in:"path",description:`ID of the ${e} to delete`,required:!0,schema:{type:"string"}},{name:"restore",in:"query",description:`Restore the ${e} instead of deleting`,required:!1,schema:{type:"boolean"}},{name:"force",in:"query",description:`Delete the ${e} permanently`,required:!1,schema:{type:"boolean"}}];exports.deleteRecordParams=deleteRecordParams;