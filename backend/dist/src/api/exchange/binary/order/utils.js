"use strict";async function getBinaryOrder(e,a,r){var t,s,i,l;try{null===(t=null==r?void 0:r.step)||void 0===t||t.call(r,"Fetching binary order "+a+" for user "+e);const l=await db_1.models.binaryOrder.findOne({where:{id:a,userId:e}});if(!l){const e="Binary order with ID "+a+" not found";null===(s=null==r?void 0:r.fail)||void 0===s||s.call(r,e);throw(0,error_1.createError)({statusCode:404,message:e})}null===(i=null==r?void 0:r.success)||void 0===i||i.call(r,"Successfully fetched binary order "+a);return l.get({plain:!0})}catch(e){null===(l=null==r?void 0:r.fail)||void 0===l||l.call(r,e.message);throw e}}async function getBinaryOrdersByStatus(e,a){var r,t,s;try{null===(r=null==a?void 0:a.step)||void 0===r||r.call(a,"Fetching binary orders with status: "+e);const s=await db_1.models.binaryOrder.findAll({where:{status:e}});null===(t=null==a?void 0:a.success)||void 0===t||t.call(a,"Successfully fetched "+s.length+" binary orders with status "+e);return s}catch(e){null===(s=null==a?void 0:a.fail)||void 0===s||s.call(a,e.message);throw e}}async function processBinaryRewards(e,a,r,t,s){var i,l,o;try{null===(i=null==s?void 0:s.step)||void 0===i||i.call(s,"Processing binary rewards for user "+e+", status: "+r);let o;"WIN"===r?o="BINARY_WIN":"LOSS"!==r&&"DRAW"!==r||(o="BINARY_TRADE_VOLUME");await(0,affiliate_1.processRewards)(e,a,o,t);null===(l=null==s?void 0:s.success)||void 0===l||l.call(s,"Successfully processed binary rewards for user "+e)}catch(e){null===(o=null==s?void 0:s.fail)||void 0===o||o.call(s,e.message);throw e}}function validateBinaryProfit(e){const a=parseFloat(e||"87");return isNaN(a)||a<0?87:a}async function ensureNotBanned(e){var a,r,t,s;try{null===(a=null==e?void 0:e.step)||void 0===a||a.call(e,"Checking ban status");const s=await(0,utils_1.loadBanStatus)();if(await(0,utils_1.handleBanStatus)(s)){const a="Service temporarily unavailable. Please try again later.";null===(r=null==e?void 0:e.fail)||void 0===r||r.call(e,a);throw(0,error_1.createError)({statusCode:503,message:a})}null===(t=null==e?void 0:e.success)||void 0===t||t.call(e,"User is not banned")}catch(a){null===(s=null==e?void 0:e.fail)||void 0===s||s.call(e,a.message);throw a}}async function ensureExchange(e=3,a=500,r){var t,s,i,l,o;try{null===(t=null==r?void 0:r.step)||void 0===t||t.call(r,"Starting exchange (max attempts: "+e+")");for(let t=0;t<e;t++){null===(s=null==r?void 0:r.step)||void 0===s||s.call(r,"Exchange start attempt "+(t+1)+"/"+e);const l=await exchange_1.default.startExchange();if(l){null===(i=null==r?void 0:r.success)||void 0===i||i.call(r,"Exchange started successfully");return l}t<e-1&&await new Promise(e=>setTimeout(e,a))}const o="Service temporarily unavailable. Please try again later.";null===(l=null==r?void 0:r.fail)||void 0===l||l.call(r,o);throw(0,error_1.createError)({statusCode:503,message:o})}catch(e){null===(o=null==r?void 0:r.fail)||void 0===o||o.call(r,e.message);throw e}}var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});exports.baseBinaryOrderSchema=void 0;exports.getBinaryOrder=getBinaryOrder;exports.getBinaryOrdersByStatus=getBinaryOrdersByStatus;exports.processBinaryRewards=processBinaryRewards;exports.validateBinaryProfit=validateBinaryProfit;exports.ensureNotBanned=ensureNotBanned;exports.ensureExchange=ensureExchange;const db_1=require("@b/db"),affiliate_1=require("@b/utils/affiliate"),exchange_1=__importDefault(require("@b/utils/exchange")),utils_1=require("@b/api/exchange/utils"),schema_1=require("@b/utils/schema"),error_1=require("@b/utils/error");exports.baseBinaryOrderSchema={id:(0,schema_1.baseStringSchema)("ID of the binary order",void 0,void 0,!1,void 0,"uuid"),userId:(0,schema_1.baseStringSchema)("User ID associated with the order"),symbol:(0,schema_1.baseStringSchema)("Trading symbol"),price:(0,schema_1.baseNumberSchema)("Entry price of the order"),amount:(0,schema_1.baseNumberSchema)("Amount of the order"),profit:(0,schema_1.baseNumberSchema)("Profit from the order"),side:(0,schema_1.baseStringSchema)("Side of the order (e.g., BUY, SELL)"),type:(0,schema_1.baseStringSchema)("Type of order (e.g., LIMIT, MARKET)"),barrier:(0,schema_1.baseNumberSchema)("Barrier price of the order",!0),strikePrice:(0,schema_1.baseNumberSchema)("Strike price of the order",!0),payoutPerPoint:(0,schema_1.baseNumberSchema)("Payout per point of the order",!0),status:(0,schema_1.baseStringSchema)("Status of the order (e.g., OPEN, CLOSED)"),isDemo:(0,schema_1.baseBooleanSchema)("Whether the order is a demo"),closedAt:(0,schema_1.baseDateTimeSchema)("Time when the order was closed",!0),closePrice:(0,schema_1.baseNumberSchema)("Price at which the order was closed"),createdAt:(0,schema_1.baseDateTimeSchema)("Creation date of the order"),updatedAt:(0,schema_1.baseDateTimeSchema)("Last update date of the order",!0)};