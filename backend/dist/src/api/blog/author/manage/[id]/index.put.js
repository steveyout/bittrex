"use strict";async function updateTags(t,e,o){await db_1.models.postTag.destroy({where:{postId:t.id},transaction:o});const s=[];for(const t of e){if(!t.id)throw(0,error_1.createError)({statusCode:400,message:"Each tag object must have an id property"});const e=await db_1.models.tag.findByPk(t.id,{transaction:o});if(!e)throw(0,error_1.createError)({statusCode:400,message:`Tag with id ${t.id} not found`});s.push(e)}await db_1.models.postTag.bulkCreate(s.map(e=>({postId:t.id,tagId:e.id})),{transaction:o})}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error");exports.metadata={summary:"Updates a blog post identified by id",description:"This endpoint updates an existing blog post.",operationId:"updatePost",tags:["Content","Author","Post"],logModule:"BLOG",logTitle:"Update blog post",requiresAuth:!0,parameters:[{index:0,name:"id",in:"path",description:"The id of the blog post to update",required:!0,schema:{type:"string",description:"Post id"}}],requestBody:{required:!0,description:"Updated blog post data",content:{"application/json":{schema:{type:"object",properties:{title:{type:"string",description:"Title of the post"},content:{type:"string",description:"Content of the post"},description:{type:"string",description:"Description of the post"},categoryId:{type:"string",description:"Category ID for the post"},status:{type:"string",description:"New status of the blog post",enum:["PUBLISHED","DRAFT"]},tags:{type:"array",description:"Array of tag objects associated with the post",items:{type:"object",properties:{id:{type:"string"}},required:["id"]}},image:{type:"string",description:"Image URL for the post"}},required:["title","content","categoryId","status"]}}}},responses:{200:{description:"Blog post updated successfully",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Confirmation message of successful post update"}}}}}},401:{description:"Unauthorized, user must be authenticated"},404:{description:"Blog post not found"},500:{description:"Internal server error"}}};exports.default=async t=>{const{params:e,body:o,user:s,ctx:r}=t;if(!(null==s?void 0:s.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});const{id:i}=e,{content:a,tags:n,categoryId:d,description:p,title:c,status:u,image:g}=o;null==r||r.step("Verifying author credentials");const l=await db_1.models.author.findOne({where:{userId:s.id}});if(!l)throw(0,error_1.createError)({statusCode:404,message:"Author not found"});return await db_1.sequelize.transaction(async t=>{null==r||r.step("Finding existing post");const e=await db_1.models.post.findOne({where:{id:i,authorId:l.id},include:[{model:db_1.models.postTag,as:"postTags"}],transaction:t});if(!e)throw(0,error_1.createError)({statusCode:404,message:"Post not found or you don't have permission to edit it."});null==r||r.step("Updating post content");e.title=c;e.content=a;e.description=p;e.status=u;e.image=g;await e.save();if(d){null==r||r.step("Updating post category");const o=await db_1.models.category.findByPk(d,{transaction:t});if(!o)throw(0,error_1.createError)({statusCode:404,message:"Category not found with the provided ID"});await e.setCategory(o,{transaction:t})}if(n){null==r||r.step("Updating post tags");await updateTags(e,n,t)}null==r||r.success(`Blog post updated: "${c}" (${i}) by author ${l.id}`);return{message:"Post updated successfully"}}).catch(t=>{null==r||r.fail("Failed to update blog post");throw t})};