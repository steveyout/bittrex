"use strict";async function updateComment(e,t,o){null==o||o.step("Validating comment status");const n=await db_1.models.comment.findByPk(e);if(!n)throw(0,error_1.createError)(404,"Comment not found");if("REJECTED"===n.status)throw(0,error_1.createError)(400,"Comment cannot be updated after rejection");null==o||o.step("Checking moderation settings");const a=cache_1.CacheManager.getInstance(),r=await a.getSettings(),s=r.has("moderateComments")?r.get("moderateComments"):null,m="boolean"==typeof s?s:Boolean(s);null==o||o.step("Saving comment update");await n.update({content:t.comment,status:m?"PENDING":"APPROVED"},{where:{id:e}});return{message:"Comment updated successfully"}}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;exports.updateComment=updateComment;const error_1=require("@b/utils/error"),db_1=require("@b/db"),query_1=require("@b/utils/query"),cache_1=require("@b/utils/cache");exports.metadata={summary:"Updates an existing blog comment",description:"This endpoint updates an existing blog comment.",operationId:"updateComment",tags:["Blog"],logModule:"BLOG",logTitle:"Update comment",requiresAuth:!0,parameters:[{index:0,name:"id",in:"path",description:"The ID of the comment to update",required:!0,schema:{type:"string",description:"Comment ID"}}],requestBody:{required:!0,description:"Comment data to update",content:{"application/json":{schema:{type:"object",properties:{comment:{type:"string",description:"Updated comment content"}},required:["comment"]}}}},responses:(0,query_1.updateRecordResponses)("Comment")};exports.default=async e=>{const{ctx:t}=e;null==t||t.step("Updating comment");const o=await updateComment(e.params.id,e.body.comment,t);null==t||t.success(`Comment ${e.params.id} updated successfully`);return o};