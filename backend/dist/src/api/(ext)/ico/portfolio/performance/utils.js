"use strict";async function getAllocationByToken(e,o,t){var l,n,i,r,a,c;try{null===(l=null==t?void 0:t.step)||void 0===l||l.call(t,"Fetching completed transactions for allocation calculation");const c=await db_1.models.icoTransaction.findAll({where:{userId:e,createdAt:{[sequelize_1.Op.lte]:o},status:"RELEASED"},include:[{model:db_1.models.icoTokenOffering,as:"offering",attributes:["currentPrice","tokenPrice","name"]}]});null===(n=null==t?void 0:t.step)||void 0===n||n.call(t,"Calculating cumulative holdings per offering");const s={},u={};c.forEach(e=>{const o=e.offeringId;e.offering&&(u[o]=e.offering.name);"buy"===e.type?s[o]=(s[o]||0)+e.amount:"sell"===e.type&&(s[o]=(s[o]||0)-e.amount)});null===(i=null==t?void 0:t.step)||void 0===i||i.call(t,"Computing market value per offering");let f=0;const d={};for(const e in s){const o=c.find(o=>o.offeringId===e);if(o&&o.offering){const t=null!==(r=o.offering.currentPrice)&&void 0!==r?r:o.offering.tokenPrice,l=s[e]*t;d[o.offering.name]=(d[o.offering.name]||0)+l;f+=l}}const g=Object.entries(d).map(([e,o])=>({name:e,percentage:f>0?o/f*100:0}));null===(a=null==t?void 0:t.success)||void 0===a||a.call(t,`Calculated allocation for ${g.length} tokens`);return{allocationByToken:g,totalPortfolioValue:f}}catch(e){null===(c=null==t?void 0:t.fail)||void 0===c||c.call(t,e.message||"Failed to calculate allocation by token");throw e}}async function getUserPortfolioHistory(e,o,t,l){var n,i,r,a,c,s,u;try{null===(n=null==l?void 0:l.step)||void 0===n||n.call(l,"Fetching transaction history for portfolio calculation");const u=await db_1.models.icoTransaction.findAll({where:{userId:e,createdAt:{[sequelize_1.Op.lte]:t},status:"RELEASED"},order:[["createdAt","ASC"]],include:[{model:db_1.models.icoTokenOffering,as:"offering",attributes:["currentPrice","tokenPrice"]}]});null===(i=null==l?void 0:l.step)||void 0===i||i.call(l,"Processing transactions before start date");const f={},d={};let g=0;for(;g<u.length&&new Date(u[g].createdAt)<o;){const e=u[g],o=e.offeringId,t=e.offering&&(null!==(r=e.offering.currentPrice)&&void 0!==r?r:e.offering.tokenPrice);null!=t&&(d[o]=t);"buy"===e.type?f[o]=(f[o]||0)+e.amount:"sell"===e.type&&(f[o]=(f[o]||0)-e.amount);g++}const p=()=>{var e;let o=0;for(const t in f){o+=f[t]*(null!==(e=d[t])&&void 0!==e?e:0)}return parseFloat(o.toFixed(2))};null===(a=null==l?void 0:l.step)||void 0===a||a.call(l,"Building daily portfolio history");const v=[],y=864e5,m=Math.floor((t.getTime()-o.getTime())/y);for(let e=0;e<=m;e++){const t=new Date(o.getTime()+e*y);for(;g<u.length&&new Date(u[g].createdAt)<=t;){const e=u[g],o=e.offeringId;e.offering&&(d[o]=null!==(c=e.offering.currentPrice)&&void 0!==c?c:e.offering.tokenPrice);"buy"===e.type?f[o]=(f[o]||0)+e.amount:"sell"===e.type&&(f[o]=(f[o]||0)-e.amount);g++}v.push({date:t.toISOString().split("T")[0],value:p()})}null===(s=null==l?void 0:l.success)||void 0===s||s.call(l,`Generated ${v.length} days of portfolio history`);return v}catch(e){null===(u=null==l?void 0:l.fail)||void 0===u||u.call(l,e.message||"Failed to generate portfolio history");throw e}}Object.defineProperty(exports,"__esModule",{value:!0});exports.getAllocationByToken=getAllocationByToken;exports.getUserPortfolioHistory=getUserPortfolioHistory;const sequelize_1=require("sequelize"),db_1=require("@b/db");