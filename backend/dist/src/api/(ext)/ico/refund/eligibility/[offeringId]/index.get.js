"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),sequelize_1=require("sequelize");exports.metadata={summary:"Check Refund Eligibility",description:"Checks if an ICO offering is eligible for refunds and returns refund details",operationId:"checkRefundEligibility",tags:["ICO","Refunds"],logModule:"ICO",logTitle:"Get Refund Eligibility",requiresAuth:!0,parameters:[{index:0,name:"offeringId",in:"path",required:!0,schema:{type:"string"},description:"ID of the ICO offering"}],responses:{200:{description:"Refund eligibility information",content:{"application/json":{schema:{type:"object",properties:{eligible:{type:"boolean"},reason:{type:"string"},offering:{type:"object"},refundDetails:{type:"object",properties:{totalInvestors:{type:"number"},totalAmount:{type:"number"},pendingRefunds:{type:"number"},completedRefunds:{type:"number"}}}}}}}},401:{description:"Unauthorized"},404:{description:"Offering not found"},500:{description:"Internal Server Error"}}};exports.default=async e=>{var t,s;const{user:r,params:i,ctx:n}=e;if(!(null==r?void 0:r.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});null==n||n.step("Fetching refund eligibility");const{offeringId:o}=i,a=await db_1.models.icoTokenOffering.findByPk(o,{attributes:["id","name","symbol","status","targetAmount","userId","purchaseWalletCurrency","startDate","endDate"]});if(!a)throw(0,error_1.createError)({statusCode:404,message:"Offering not found"});const d=a.userId===r.id,u=await db_1.models.user.findByPk(r.id,{include:[{model:db_1.models.role,as:"role"}]}),l="admin"===(null===(t=null==u?void 0:u.role)||void 0===t?void 0:t.name)||"super_admin"===(null===(s=null==u?void 0:u.role)||void 0===s?void 0:s.name),f=await db_1.models.icoTransaction.count({where:{offeringId:a.id,userId:r.id}})>0;if(!d&&!l&&!f)throw(0,error_1.createError)({statusCode:403,message:"You don't have permission to view refund details"});let c=!1,m="";const p=new Date,g=await db_1.models.icoTransaction.sum("amount",{where:{offeringId:a.id,status:{[sequelize_1.Op.in]:["PENDING","VERIFICATION","RELEASED","REFUNDED"]}},raw:!0})||0,E=.3*a.targetAmount;if("FAILED"===a.status||"CANCELLED"===a.status){c=!0;m=`Offering ${a.status.toLowerCase()}`}else if("REFUNDED"===a.status){c=!1;m="Refunds already processed"}else if(p>a.endDate&&g<E){c=!0;m="Soft cap not reached after offering ended"}else if("ACTIVE"===a.status&&p>a.endDate){c=!1;m="Offering ended successfully"}else{c=!1;m="Offering is still active or completed successfully"}const I=await db_1.models.icoTransaction.findAll({where:{offeringId:a.id},attributes:["status","amount","price"]}),b={totalInvestors:0,totalAmount:0,pendingRefunds:0,completedRefunds:0},y=new Set;for(const e of I)if(["PENDING","VERIFICATION","RELEASED","REFUND_PENDING","REFUNDED"].includes(e.status)){y.add(e.userId);const t=e.amount*e.price;b.totalAmount+=t;"REFUNDED"===e.status?b.completedRefunds++:["PENDING","VERIFICATION","REFUND_PENDING"].includes(e.status)&&b.pendingRefunds++}b.totalInvestors=y.size;null==n||n.success("Get Refund Eligibility retrieved successfully");return{eligible:c,reason:m,offering:{id:a.id,name:a.name,symbol:a.symbol,status:a.status,targetAmount:a.targetAmount,totalRaised:g,softCap:E,currency:a.purchaseWalletCurrency,startDate:a.startDate,endDate:a.endDate},refundDetails:b}};