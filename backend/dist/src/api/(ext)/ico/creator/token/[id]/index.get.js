"use strict";function computeTimeline(e){const t=[];e.createdAt&&t.push({id:"created",title:"Created",date:e.createdAt});e.startDate&&"ACTIVE"===e.status&&t.push({id:"launched",title:"Launched",date:e.startDate});e.endDate&&t.push({id:"completed",title:"Completed",date:e.endDate});return t}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),sequelize_1=require("sequelize");exports.metadata={summary:"Get ICO Offering by ID (Creator)",description:"Retrieves detailed ICO offering data (including phases, token detail, team members, roadmap items, launch plan, computed stats, investor count, and rejected funds) for the authenticated creator.",operationId:"getCreatorIcoOfferingById",tags:["ICO","Creator","Offerings"],logModule:"ICO",logTitle:"Get Creator Token",requiresAuth:!0,parameters:[{index:0,name:"id",in:"path",description:"ICO offering ID",required:!0,schema:{type:"string"}}],responses:{200:{description:"ICO offering retrieved successfully."},401:{description:"Unauthorized"},404:{description:"Offering not found"},500:{description:"Internal Server Error"}}};exports.default=async e=>{const{user:t,params:a,ctx:r}=e;if(!(null==t?void 0:t.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});null==r||r.step("Fetching creator token");const{id:s}=a;if(!s)throw(0,error_1.createError)({statusCode:400,message:"No offering ID provided"});const n=await db_1.models.icoTokenOffering.findOne({where:{id:s,userId:t.id},include:[{model:db_1.models.icoTokenOfferingPhase,as:"phases"},{model:db_1.models.icoTokenDetail,as:"tokenDetail",include:[{model:db_1.models.icoTokenType,as:"tokenTypeData"}]},{model:db_1.models.icoLaunchPlan,as:"plan"}]});if(!n)throw(0,error_1.createError)({statusCode:404,message:"Offering not found"});const i=new Date,o=n.phases||[];let d=0,l=null,u=null;const c=new Date(n.startDate),p=Math.floor((i.getTime()-c.getTime())/864e5);for(let e=0;e<o.length;e++){d+=o[e].duration;if(p<d){const t=d-p;l={...o[e].toJSON(),endsIn:t};e+1<o.length&&(u={...o[e+1].toJSON(),endsIn:o[e+1].duration});break}}const f=await db_1.models.icoTransaction.findOne({attributes:[[(0,sequelize_1.fn)("COALESCE",(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("amount * price")),0),"validFundsRaised"]],where:{offeringId:n.id,status:{[sequelize_1.Op.not]:["REJECTED"]}},raw:!0}),m=parseFloat(f.validFundsRaised)||0,g=await db_1.models.icoTransaction.findOne({attributes:[[(0,sequelize_1.fn)("COALESCE",(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("amount * price")),0),"rejectedFunds"]],where:{offeringId:n.id,status:"REJECTED"},raw:!0}),h=parseFloat(g.rejectedFunds)||0,C=(await db_1.models.icoTransaction.findAll({attributes:["userId"],where:{offeringId:n.id,status:{[sequelize_1.Op.in]:["PENDING","RELEASED"]}},group:["userId"],raw:!0})).length,D=n.targetAmount,O="ACTIVE"===n.status&&n.startDate?n.startDate:null,I=computeTimeline(n),_={id:n.id,name:n.name,symbol:n.symbol,icon:n.icon,purchaseWalletCurrency:n.purchaseWalletCurrency,purchaseWalletType:n.purchaseWalletType,status:n.status,tokenPrice:n.tokenPrice,targetAmount:n.targetAmount,participants:n.participants,isPaused:n.isPaused,isFlagged:n.isFlagged,startDate:n.startDate,endDate:n.endDate,currentPhase:l,nextPhase:u,phases:o.map(e=>e.toJSON()),tokenDetail:n.tokenDetail?n.tokenDetail.toJSON():null,plan:n.plan?n.plan.toJSON():null,fundsRaised:m,rejectedFunds:h,fundingGoal:D,launchDate:O,timeline:I,investorsCount:C};null==r||r.success("Creator token retrieved successfully");return _};