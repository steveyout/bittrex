"use strict";async function checkAndProcessFailedOfferings(){const e=await db_1.sequelize.transaction();try{const t=new Date,a=await db_1.models.icoTokenOffering.findAll({where:{status:"ACTIVE",endDate:{[sequelize_1.Op.lt]:t}},include:[{model:db_1.models.icoTokenDetail,as:"tokenDetail"}],transaction:e});for(const n of a){const a=await db_1.models.icoTransaction.sum("amount",{where:{offeringId:n.id,status:{[sequelize_1.Op.in]:["PENDING","VERIFICATION","RELEASED"]}},transaction:e})||0,i=.3*n.targetAmount;if(a<i){await n.update({status:"FAILED",notes:JSON.stringify({failureReason:"Soft cap not reached",totalRaised:a,softCap:i,failedAt:t.toISOString()})},{transaction:e});await db_1.models.icoTransaction.update({status:"REJECTED",notes:JSON.stringify({rejectionReason:"Soft cap not reached - pending refund",rejectedAt:t.toISOString()})},{where:{offeringId:n.id,status:{[sequelize_1.Op.in]:["PENDING","VERIFICATION"]}},transaction:e});await(0,notifications_1.createNotification)({userId:n.userId,relatedId:n.id,type:"system",title:"ICO Offering Failed",message:`${n.name} failed to reach soft cap`,details:`Total raised: ${a} ${n.purchaseWalletCurrency}\nSoft cap: ${i} ${n.purchaseWalletCurrency}\nRefunds will be processed for all investors.`,link:`/ico/creator/token/${n.id}`,actions:[{label:"Process Refunds",link:`/ico/creator/token/${n.id}/refunds`,primary:!0}]});const o=await db_1.models.icoTransaction.findAll({where:{offeringId:n.id,status:"REJECTED"},attributes:["userId"],group:["userId"],transaction:e});for(const e of o)await(0,notifications_1.createNotification)({userId:e.userId,relatedId:n.id,type:"investment",title:"ICO Investment Refund Available",message:`${n.name} did not reach its funding goal`,details:`Your investment will be refunded. The ICO failed to reach its soft cap of ${i} ${n.purchaseWalletCurrency}.`,link:"/ico/dashboard?tab=transactions"});await db_1.models.icoAdminActivity.create({type:"OFFERING_FAILED",offeringId:n.id,offeringName:n.name,adminId:null,details:JSON.stringify({reason:"Soft cap not reached",totalRaised:a,softCap:i,currency:n.purchaseWalletCurrency,investorCount:o.length})},{transaction:e})}}await e.commit()}catch(t){await e.rollback();console_1.logger.error("ICO_REFUND","Error checking failed offerings",t);throw t}}async function processAutomaticRefunds(){const e=await db_1.sequelize.transaction();try{const t=await db_1.models.icoTokenOffering.findAll({where:{status:{[sequelize_1.Op.in]:["FAILED","CANCELLED"]}},transaction:e});for(const a of t){if(0===await db_1.models.icoTransaction.count({where:{offeringId:a.id,status:"REJECTED"},transaction:e}))continue;const t=await db_1.models.icoTransaction.findAll({where:{offeringId:a.id,status:"REJECTED"},transaction:e});let n=0,i=0;for(const o of t)try{const t=o.amount*o.price,r=await db_1.models.wallet.findOne({where:{userId:o.userId,type:a.purchaseWalletType,currency:a.purchaseWalletCurrency},transaction:e,lock:e.LOCK.UPDATE});if(!r)continue;const s=`ico_auto_refund_${o.id}`;await wallet_1.walletService.credit({idempotencyKey:s,userId:o.userId,walletId:r.id,walletType:a.purchaseWalletType,currency:a.purchaseWalletCurrency,amount:t,operationType:"REFUND",referenceId:o.id,description:`Automatic ICO Refund: ${a.name}`,metadata:{offeringId:a.id,offeringName:a.name,originalTransactionId:o.transactionId,reason:"Automatic refund - offering failed",processedBy:"SYSTEM"},transaction:e});await o.update({notes:JSON.stringify({...JSON.parse(o.notes||"{}"),refund:{amount:t,reason:"Automatic refund - offering failed",processedAt:(new Date).toISOString(),processedBy:"SYSTEM"}})},{transaction:e});n++;i+=t}catch(e){console_1.logger.error("ICO_REFUND",`Failed to refund transaction ${o.id}`,e)}n===t.length&&await a.update({notes:JSON.stringify({...JSON.parse(a.notes||"{}"),automaticRefund:{refundedAt:(new Date).toISOString(),refundedCount:n,totalRefunded:i,allRefundsProcessed:!0}})},{transaction:e})}await e.commit()}catch(t){await e.rollback();console_1.logger.error("ICO_REFUND","Error processing automatic refunds",t);throw t}}Object.defineProperty(exports,"__esModule",{value:!0});exports.checkAndProcessFailedOfferings=checkAndProcessFailedOfferings;exports.processAutomaticRefunds=processAutomaticRefunds;const db_1=require("@b/db"),sequelize_1=require("sequelize"),notifications_1=require("@b/utils/notifications"),console_1=require("@b/utils/console"),wallet_1=require("@b/services/wallet");