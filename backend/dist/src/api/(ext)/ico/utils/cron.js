"use strict";async function processIcoOfferings(){const e="processIcoOfferings",s=Date.now();try{(0,broadcast_1.broadcastStatus)(e,"running");(0,broadcast_1.broadcastLog)(e,"Starting ICO offerings processing");const a=await db_1.models.icoTokenOffering.findAll({where:{status:{[sequelize_1.Op.in]:["UPCOMING","ACTIVE"]}}});(0,broadcast_1.broadcastLog)(e,`Found ${a.length} ICO offerings to evaluate`,"info");const t=new Date;for(const s of a)try{if("UPCOMING"===s.status&&s.startDate&&t>=s.startDate){await s.update({status:"ACTIVE"});(0,broadcast_1.broadcastLog)(e,`Offering ${s.id} changed from UPCOMING to ACTIVE`,"success")}else if("ACTIVE"===s.status&&s.endDate&&t>=s.endDate){await s.update({status:"SUCCESS"});(0,broadcast_1.broadcastLog)(e,`Offering ${s.id} changed from ACTIVE to SUCCESS`,"success")}else(0,broadcast_1.broadcastLog)(e,`Offering ${s.id} not eligible for update (status: ${s.status}, startDate: ${s.startDate}, endDate: ${s.endDate})`,"info")}catch(a){console_1.logger.error("ICO_OFFERING_PROCESS",`Error updating offering ${s.id}: ${a.message}`,a);(0,broadcast_1.broadcastLog)(e,`Error updating offering ${s.id}: ${a.message}`,"error")}(0,broadcast_1.broadcastStatus)(e,"completed",{duration:Date.now()-s});(0,broadcast_1.broadcastLog)(e,"ICO offerings processing completed","success")}catch(s){console_1.logger.error("ICO_OFFERING_PROCESS",`ICO offerings processing failed: ${s.message}`,s);(0,broadcast_1.broadcastStatus)(e,"failed");(0,broadcast_1.broadcastLog)(e,`ICO offerings processing failed: ${s.message}`,"error");throw s}}Object.defineProperty(exports,"__esModule",{value:!0});exports.processIcoOfferings=processIcoOfferings;const db_1=require("@b/db"),sequelize_1=require("sequelize"),console_1=require("@b/utils/console"),broadcast_1=require("@b/cron/broadcast");