"use strict";async function handler(e){var t,r;const{id:a}=e.params||{},{amount:i,paymentMethodId:o,message:n}=e.body,{user:s,ctx:l}=e;if(!(null==s?void 0:s.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});null==l||l.step("Finding and locking offer");let d;try{d=await db_1.sequelize.transaction();const e=await db_1.models.p2pOffer.findOne({where:{id:a,status:"ACTIVE",userId:{[sequelize_1.Op.ne]:s.id}},include:[{model:db_1.models.user,as:"user",attributes:["id","firstName","lastName","email"]},{model:db_1.models.p2pPaymentMethod,as:"paymentMethods",through:{attributes:[]}}],lock:!0,transaction:d});if(!e)throw(0,error_1.createError)({statusCode:404,message:"Offer not found or unavailable"});null==l||l.step("Validating trade amount against offer limits");const r=(0,json_parser_1.parseAmountConfig)(e.amountConfig),c=(0,json_parser_1.parsePriceConfig)(e.priceConfig),{min:u,max:f,total:m}=r,p=c.finalPrice;if(p<=0)throw(0,error_1.createError)({statusCode:500,message:"Invalid offer configuration: price must be greater than 0"});const y=!!await db_1.models.currency.findOne({where:{id:e.currency,status:!0},transaction:d});let _,g;if(y){_=u||0;g=f||m||0}else{_=(u||0)/p;g=(f||m||0)/p}if(i<_||i>g)throw(0,error_1.createError)({statusCode:400,message:`Amount must be between ${_} and ${g} ${e.currency}`});const{validateMinimumTradeAmount:w}=await Promise.resolve().then(()=>__importStar(require("../../utils/fees"))),h=await w(i,e.currency);if(!h.valid)throw(0,error_1.createError)({statusCode:400,message:h.message||`Amount below minimum for ${e.currency}`});const{CacheManager:b}=await Promise.resolve().then(()=>__importStar(require("@b/utils/cache"))),T=b.getInstance(),I=await T.getSetting("p2pMinimumTradeAmount"),v=await T.getSetting("p2pMaximumTradeAmount"),P=y?i:i*p;if(I&&P<I)throw(0,error_1.createError)({statusCode:400,message:`Trade amount (${P.toFixed(2)} ${c.currency||"USD"}) is below platform minimum of ${I}`});if(v&&P>v)throw(0,error_1.createError)({statusCode:400,message:`Trade amount (${P.toFixed(2)} ${c.currency||"USD"}) exceeds platform maximum of ${v}`});if(!e.paymentMethods.map(e=>e.id).includes(o))throw(0,error_1.createError)({statusCode:400,message:"Selected payment method not allowed for this offer"});const E=await db_1.models.p2pPaymentMethod.findOne({where:{id:o,available:!0},transaction:d});if(!E)throw(0,error_1.createError)({statusCode:400,message:"Invalid or unavailable payment method"});const A="BUY"===e.type,O=A?e.userId:s.id,C=A?s.id:e.userId;null==l||l.step("Verifying seller balance and locking funds");let F=await(0,utils_1.getWalletSafe)(C,e.walletType,e.currency,!1,l);if(A){null==l||l.step(`Locking ${i} ${e.currency} for seller (BUY offer)`);if(!F)if("ECO"===e.walletType){const t=await(0,safe_imports_1.getEcosystemWalletUtils)();if(!(0,safe_imports_1.isServiceAvailable)(t))throw(0,error_1.createError)({statusCode:503,message:"Ecosystem wallet service is not available"});const{getWalletByUserIdAndCurrency:r}=t,a=await db_1.models.user.findByPk(C,{transaction:d});F=await r(a,e.currency)}else{F=(await wallet_1.walletCreationService.getOrCreateWallet(C,e.walletType,e.currency,d)).wallet}if(!F)throw(0,error_1.createError)({statusCode:500,message:"Failed to create or retrieve seller wallet"});const t=F.balance-F.inOrder;if(t<i)throw(0,error_1.createError)({statusCode:409,message:`Insufficient balance. Available: ${t} ${e.currency}, Required: ${i} ${e.currency}. Please deposit more funds to your ${e.walletType} wallet.`});const r=`p2p_trade_lock_${e.id}_${s.id}`;await wallet_1.walletService.hold({idempotencyKey:r,userId:C,walletId:F.id,walletType:e.walletType,currency:e.currency,amount:i,operationType:"P2P_TRADE_LOCK",description:`Lock ${i} ${e.currency} for P2P BUY offer trade`,metadata:{offerId:e.id,offerType:e.type,initiatedBy:s.id},transaction:d})}else{if(!F)throw(0,error_1.createError)({statusCode:500,message:"Seller wallet not found. The offer may be invalid."});if(F.inOrder<i)throw(0,error_1.createError)({statusCode:409,message:`This offer is currently unavailable. The seller does not have sufficient ${e.currency} balance to complete this trade.`})}(0,audit_1.createP2PAuditLog)({userId:C,eventType:audit_1.P2PAuditEventType.TRADE_INITIATED,entityType:"TRADE",entityId:e.id,metadata:{offerId:e.id,amount:i,currency:e.currency,walletType:e.walletType,walletInOrder:F.inOrder,note:"FIAT"===e.walletType?"FIAT trade - balance locked on platform, payment happens peer-to-peer":"Trade initiated - funds locked in escrow at trade initiation",initiatedBy:s.id},riskLevel:audit_1.P2PRiskLevel.HIGH}).catch(e=>console_1.logger.error("P2P_TRADE","Failed to create audit log",e));null==l||l.step("Calculating trade fees");const{calculateTradeFees:$,calculateEscrowFee:D}=await Promise.resolve().then(()=>__importStar(require("../../utils/fees"))),S=await $(i,e.currency,e.userId,s.id,O,C),q=await D(i,e.currency);null==l||l.step("Creating trade record");let M={};if(E.metadata)if("string"==typeof E.metadata)try{M=JSON.parse(E.metadata)}catch(e){M={}}else"object"==typeof E.metadata&&(M=E.metadata);const R={name:E.name,icon:E.icon,instructions:E.instructions||null,processingTime:E.processingTime||null,...M},k=await db_1.models.p2pTrade.create({offerId:e.id,buyerId:O,sellerId:C,type:e.type,amount:i,price:c.finalPrice,total:i*c.finalPrice,currency:e.currency,paymentMethod:o,paymentDetails:R,status:"PENDING",escrowFee:q.toString(),buyerFee:S.buyerFee,sellerFee:S.sellerFee,timeline:[{event:"TRADE_INITIATED",message:"Trade initiated",userId:s.id,createdAt:(new Date).toISOString()},...n?[{event:"MESSAGE",message:n,userId:s.id,createdAt:(new Date).toISOString()}]:[]]},{transaction:d}),x=r.total-i;if(x<0)throw(0,error_1.createError)({statusCode:409,message:`Insufficient offer amount. Available: ${r.total} ${e.currency}, Requested: ${i} ${e.currency}`});const j=null!==(t=r.originalTotal)&&void 0!==t?t:r.total+i;await e.update({amountConfig:{...r,total:x,originalTotal:j}},{transaction:d});null==l||l.step("Updating offer available amount");await d.commit();null==l||l.success(`Initiated ${e.type} trade: ${i} ${e.currency} @ ${c.finalPrice}`);(0,audit_1.createP2PAuditLog)({userId:s.id,eventType:audit_1.P2PAuditEventType.TRADE_INITIATED,entityType:"TRADE",entityId:k.id,metadata:{offerId:e.id,amount:i,currency:e.currency,price:c.finalPrice,paymentMethodId:o,buyerId:O,sellerId:C,buyerFee:S.buyerFee,sellerFee:S.sellerFee,escrowFee:q,totalValue:i*c.finalPrice,offerType:e.type,walletType:e.walletType},riskLevel:i>1e3?audit_1.P2PRiskLevel.HIGH:audit_1.P2PRiskLevel.MEDIUM}).catch(e=>console_1.logger.error("P2P_TRADE","Failed to create audit log",e));db_1.models.p2pOffer.increment("views",{where:{id:a}}).catch(e=>{console_1.logger.error("P2P_OFFER","Failed to increment views",e)});(0,notifications_1.notifyTradeEvent)(k.id,"TRADE_INITIATED",{buyerId:O,sellerId:C,amount:i,currency:e.currency,initiatorId:s.id}).catch(console.error);return{message:"Trade initiated successfully",trade:{id:k.id,amount:k.amount,total:k.total,status:k.status,buyer:A?e.user:{id:s.id},seller:A?{id:s.id}:e.user,fees:{buyerFee:S.buyerFee,sellerFee:S.sellerFee,escrowFee:q,totalFee:S.totalFee},netAmounts:{buyer:S.netAmountBuyer,seller:S.netAmountSeller}}}}catch(e){if(d)try{d.finished||await d.rollback()}catch(e){(null===(r=e.message)||void 0===r?void 0:r.includes("already been finished"))||console_1.logger.error("P2P_TRADE","Transaction rollback failed",e)}if(e.statusCode)throw e;throw(0,error_1.createError)({statusCode:500,message:`Failed to initiate trade: ${e.message}`})}}var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}});Object.defineProperty(e,a,i)}:function(e,t,r,a){void 0===a&&(a=r);e[a]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(){var e=function(t){e=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t};return e(t)};return function(t){if(t&&t.__esModule)return t;var r={};if(null!=t)for(var a=e(t),i=0;i<a.length;i++)"default"!==a[i]&&__createBinding(r,t,a[i]);__setModuleDefault(r,t);return r}}();Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;exports.default=handler;const db_1=require("@b/db"),error_1=require("@b/utils/error"),utils_1=require("@b/api/finance/wallet/utils"),notifications_1=require("@b/api/(ext)/p2p/utils/notifications"),audit_1=require("@b/api/(ext)/p2p/utils/audit"),sequelize_1=require("sequelize"),json_parser_1=require("@b/api/(ext)/p2p/utils/json-parser"),safe_imports_1=require("@b/utils/safe-imports"),console_1=require("@b/utils/console"),wallet_1=require("@b/services/wallet");exports.metadata={summary:"Initiate Trade from P2P Offer",description:"Creates a new trade from an active P2P offer with proper validation and balance locking",operationId:"initiateP2PTrade",tags:["P2P","Trade"],requiresAuth:!0,logModule:"P2P_TRADE",logTitle:"Initiate P2P trade",parameters:[{index:0,name:"id",in:"path",description:"Offer ID",required:!0,schema:{type:"string",format:"uuid"}}],requestBody:{description:"Trade initiation details",required:!0,content:{"application/json":{schema:{type:"object",properties:{amount:{type:"number",minimum:0,description:"Amount to trade"},paymentMethodId:{type:"string",format:"uuid",description:"Selected payment method ID"},message:{type:"string",maxLength:500,description:"Optional initial message"}},required:["amount","paymentMethodId"]}}}},responses:{200:{description:"Trade initiated successfully."},400:{description:"Bad Request - Invalid offer or amount."},401:{description:"Unauthorized."},404:{description:"Offer not found."},409:{description:"Conflict - Offer unavailable or insufficient balance."},500:{description:"Internal Server Error."}}};