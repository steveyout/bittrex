"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),sequelize_1=require("sequelize");exports.metadata={summary:"Get Staking Pool Analytics",description:"Retrieves detailed analytics for a specific staking pool.",operationId:"getStakingPoolAnalytics",tags:["Staking","Pools","Analytics"],requiresAuth:!0,parameters:[{index:0,name:"id",in:"path",required:!0,schema:{type:"string"},description:"Pool ID"},{index:1,name:"timeframe",in:"query",required:!1,schema:{type:"string",enum:["week","month","year","all"]},description:"Timeframe for analytics data"}],responses:{200:{description:"Pool analytics retrieved successfully",content:{"application/json":{schema:{type:"object",properties:{analytics:{type:"object"}}}}}},401:{description:"Unauthorized"},404:{description:"Pool not found"},500:{description:"Internal Server Error"}}};exports.default=async e=>{const{user:t,params:a,query:o}=e;if(!(null==t?void 0:t.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});const{id:i}=a,s=o.timeframe||"month",r=await db_1.models.stakingPool.findOne({where:{id:i}});if(!r)throw(0,error_1.createError)({statusCode:404,message:"Pool not found"});const n=new Date;let l;switch(s){case"week":l=new Date(n);l.setDate(n.getDate()-7);break;case"month":default:l=new Date(n);l.setMonth(n.getMonth()-1);break;case"year":l=new Date(n);l.setFullYear(n.getFullYear()-1);break;case"all":l=new Date(0)}const d=await db_1.models.stakingPosition.sum("amount",{where:{poolId:r.id,status:{[sequelize_1.Op.in]:["ACTIVE","COMPLETED"]}}}),u=await db_1.models.stakingPosition.count({where:{poolId:r.id,status:{[sequelize_1.Op.in]:["ACTIVE","COMPLETED"]}},distinct:!0,col:"userId"}),c=await db_1.models.stakingEarningRecord.sum("amount",{where:{poolId:r.id,createdAt:{[sequelize_1.Op.gte]:l}}}),p=await db_1.models.stakingExternalPoolPerformance.findAll({where:{poolId:r.id,date:{[sequelize_1.Op.gte]:l}},order:[["date","ASC"]]}),m=await db_1.models.stakingPosition.findAll({attributes:[[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("createdAt")),"date"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("amount")),"totalAmount"],[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.col)("id")),"count"]],where:{poolId:r.id,createdAt:{[sequelize_1.Op.gte]:l}},group:[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("createdAt"))],order:[[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("createdAt")),"ASC"]],raw:!0}),_=await db_1.models.stakingPosition.findAll({attributes:[[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("updatedAt")),"date"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("amount")),"totalAmount"],[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.col)("id")),"count"]],where:{poolId:r.id,status:"COMPLETED",updatedAt:{[sequelize_1.Op.gte]:l}},group:[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("updatedAt"))],order:[[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("updatedAt")),"ASC"]],raw:!0});return{analytics:{poolId:r.id,poolName:r.name,tokenSymbol:r.symbol,apr:r.apr,totalStaked:d||0,totalStakers:u||0,totalEarnings:c||0,performanceHistory:p,stakingGrowth:m,withdrawals:_,timeframe:s}}};