"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const notifications_1=require("@b/utils/notifications"),db_1=require("@b/db"),error_1=require("@b/utils/error");exports.metadata={summary:"Request Withdrawal from Staking Position",description:"Initiates a withdrawal request for a specific staking position.",operationId:"withdrawStakingPosition",tags:["Staking","Positions","Withdrawal"],requiresAuth:!0,logModule:"STAKING",logTitle:"Request withdrawal",parameters:[{index:0,name:"id",in:"path",required:!0,schema:{type:"string"},description:"Position ID"}],responses:{200:{description:"Withdrawal request submitted successfully",content:{"application/json":{schema:{type:"object",properties:{success:{type:"boolean"},message:{type:"string"},position:{type:"object"}}}}}},400:{description:"Invalid request"},401:{description:"Unauthorized"},403:{description:"Forbidden - Not position owner"},404:{description:"Position not found"},500:{description:"Internal Server Error"}}};exports.default=async t=>{const{user:i,params:e,body:s,ctx:o}=t;if(!(null==i?void 0:i.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});const{id:a}=e;null==o||o.step("Retrieving staking position");const r=await db_1.sequelize.transaction();try{const t=await db_1.models.stakingPosition.findOne({where:{id:a},include:[{model:db_1.models.stakingPool,as:"pool"}],transaction:r,lock:r.LOCK.UPDATE});if(!t){await r.rollback();throw(0,error_1.createError)({statusCode:404,message:"Position not found"})}null==o||o.step("Verifying position ownership");if(t.userId!==i.id){await r.rollback();throw(0,error_1.createError)({statusCode:403,message:"You don't have access to this position"})}null==o||o.step("Validating position status");if("PENDING_WITHDRAWAL"===t.status){await r.rollback();throw(0,error_1.createError)({statusCode:400,message:"Withdrawal already in progress"})}if("COMPLETED"===t.status){await r.rollback();throw(0,error_1.createError)({statusCode:400,message:"Position is already withdrawn"})}const e=t.amount;null==o||o.step("Updating position status to pending withdrawal");await db_1.models.stakingPosition.update({status:"PENDING_WITHDRAWAL",withdrawalRequested:!0,withdrawalRequestDate:new Date},{where:{id:t.id},transaction:r});null==o||o.step("Creating withdrawal notification");await(0,notifications_1.createNotification)({userId:i.id,relatedId:t.id,type:"system",title:"Staking Withdrawal Requested",message:`Your withdrawal request for ${e} ${t.pool.symbol} has been submitted and is pending approval.`,link:`/staking/positions/${t.id}`,actions:[{label:"View Position",link:`/staking/positions/${t.id}`,primary:!0}]});null==o||o.step("Retrieving updated position details");const s=await db_1.models.stakingPosition.findOne({where:{id:a},include:[{model:db_1.models.stakingPool,as:"pool"}],transaction:r});await r.commit();null==o||o.success(`Withdrawal request submitted for ${e} ${t.pool.symbol}`);return{success:!0,message:"Withdrawal request submitted successfully",position:s}}catch(t){await r.rollback();null==o||o.fail(t.message||"Failed to process withdrawal request");throw t}};