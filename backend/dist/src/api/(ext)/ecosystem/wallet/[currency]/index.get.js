"use strict";async function getActiveCustodialWallets(e,t){var s,r;null===(s=null==t?void 0:t.step)||void 0===s||s.call(t,`Fetching active custodial wallets for ${e}`);const a=await db_1.models.ecosystemCustodialWallet.findAll({where:{chain:e,status:"ACTIVE"},attributes:["id","address","chain","network"]});null===(r=null==t?void 0:t.success)||void 0===r||r.call(t,`Found ${a.length} active custodial wallet(s) for ${e}`);return a}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;exports.getActiveCustodialWallets=getActiveCustodialWallets;const error_1=require("@b/utils/error"),utils_1=require("../utils"),query_1=require("@b/utils/query"),wallet_1=require("@b/api/(ext)/ecosystem/utils/wallet"),db_1=require("@b/db");exports.metadata={summary:"Fetches a specific wallet by currency",description:"Retrieves details of a wallet associated with the logged-in user by its currency.",operationId:"getWallet",tags:["Wallet","User"],requiresAuth:!0,logModule:"ECOSYSTEM",logTitle:"Get wallet by currency",parameters:[{index:0,name:"currency",in:"path",required:!0,schema:{type:"string",description:"Currency of the wallet"}},{name:"contractType",in:"query",schema:{type:"string",description:"Chain of the wallet address"}},{name:"chain",in:"query",schema:{type:"string",description:"Chain of the wallet address"}}],responses:{200:{description:"Wallet retrieved successfully",content:{"application/json":{schema:{type:"object",properties:utils_1.baseWalletSchema}}}},401:query_1.unauthorizedResponse,404:(0,query_1.notFoundMetadataResponse)("Wallet"),500:query_1.serverErrorResponse}};exports.default=async e=>{var t;const{params:s,user:r,query:a,ctx:l}=e;if(!(null==r?void 0:r.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});const{currency:i}=s,{contractType:o,chain:n}=a;let c;try{null==l||l.step(`Fetching wallet for ${i}`);c=await(0,wallet_1.getWalletByUserIdAndCurrency)(r.id,i)}catch(e){console.error(`[WALLET_ERROR] Failed to get/create wallet for user ${r.id}, currency ${i}:`,e);console.error("[WALLET_ERROR] Error details:",{message:e.message,stack:e.stack,original:null===(t=e.original)||void 0===t?void 0:t.message,sql:e.sql});null==l||l.fail(`Failed to get wallet: ${e.message}`);throw(0,error_1.createError)({statusCode:500,message:`Failed to get wallet: ${e.message}`})}if("NO_PERMIT"===o){null==l||l.step("Processing NO_PERMIT wallet request");await(0,utils_1.unlockExpiredAddresses)(l);try{const e=await getActiveCustodialWallets(n,l),t=[];null==l||l.step("Checking wallet availability");for(const s of e)await(0,utils_1.isAddressLocked)(s.address,l)||t.push(s);if(0===t.length){null==l||l.fail("No available custodial wallets");throw(0,error_1.createError)({statusCode:404,message:"All custodial wallets are currently in use. Please try again later."})}const s=t[Math.floor(Math.random()*t.length)];(0,utils_1.lockAddress)(s.address,l);null==l||l.success(`Assigned custodial wallet ${s.address.substring(0,10)}... for ${n}`);return s}catch(e){if(e.statusCode){null==l||l.fail(e.message);throw e}null==l||l.fail(e.message);throw(0,error_1.createError)({statusCode:500,message:e.message})}}null==l||l.success(`Retrieved wallet for ${i}`);return c};