"use strict";function lockAddress(e,s){var a,t;null===(a=null==s?void 0:s.step)||void 0===a||a.call(s,`Locking address ${e.substring(0,10)}...`);lockedAddressesCache.set(e,Date.now());console.info(`Locked address ${e}`);null===(t=null==s?void 0:s.success)||void 0===t||t.call(s,`Address ${e.substring(0,10)}... locked`)}function isAddressLocked(e,s){var a,t;null===(a=null==s?void 0:s.step)||void 0===a||a.call(s,`Checking if address ${e.substring(0,10)}... is locked`);const l=lockedAddressesCache.has(e);l&&(null===(t=null==s?void 0:s.step)||void 0===t||t.call(s,`Address ${e.substring(0,10)}... is locked`));return l}function unlockAddress(e,s){var a,t;null===(a=null==s?void 0:s.step)||void 0===a||a.call(s,`Unlocking address ${e.substring(0,10)}...`);lockedAddressesCache.delete(e);console.info(`Unlocked address ${e}`);null===(t=null==s?void 0:s.success)||void 0===t||t.call(s,`Address ${e.substring(0,10)}... unlocked`)}function unlockExpiredAddresses(e){var s,a,t;null===(s=null==e?void 0:e.step)||void 0===s||s.call(e,"Checking for expired locked addresses");const l=Date.now();let c=0;lockedAddressesCache.forEach((s,a)=>{if(l-s>36e5){unlockAddress(a,e);c++}});c>0?null===(a=null==e?void 0:e.success)||void 0===a||a.call(e,`Unlocked ${c} expired address(es)`):null===(t=null==e?void 0:e.step)||void 0===t||t.call(e,"No expired addresses found")}async function getActiveCustodialWallets(e,s){var a,t;null===(a=null==s?void 0:s.step)||void 0===a||a.call(s,`Fetching active custodial wallets for ${e}`);const l=await db_1.models.ecosystemCustodialWallet.findAll({where:{chain:e,status:"ACTIVE"}});null===(t=null==s?void 0:s.success)||void 0===t||t.call(s,`Found ${l.length} active custodial wallet(s) for ${e}`);return l}Object.defineProperty(exports,"__esModule",{value:!0});exports.baseWalletSchema=exports.baseTransactionSchema=void 0;exports.lockAddress=lockAddress;exports.isAddressLocked=isAddressLocked;exports.unlockAddress=unlockAddress;exports.unlockExpiredAddresses=unlockExpiredAddresses;exports.getActiveCustodialWallets=getActiveCustodialWallets;const db_1=require("@b/db"),schema_1=require("@b/utils/schema");exports.baseTransactionSchema={id:(0,schema_1.baseStringSchema)("Transaction ID"),type:(0,schema_1.baseStringSchema)("Transaction type"),status:(0,schema_1.baseStringSchema)("Transaction status"),amount:(0,schema_1.baseNumberSchema)("Transaction amount"),fee:(0,schema_1.baseNumberSchema)("Transaction fee"),description:(0,schema_1.baseStringSchema)("Transaction description"),metadata:{type:"object",description:"Additional metadata for the transaction"},referenceId:(0,schema_1.baseStringSchema)("Reference ID"),createdAt:(0,schema_1.baseStringSchema)("Creation time of the transaction",void 0,void 0,!1,"date-time")};exports.baseWalletSchema={id:(0,schema_1.baseStringSchema)("Wallet ID"),type:(0,schema_1.baseStringSchema)("Wallet type"),currency:(0,schema_1.baseStringSchema)("Wallet currency"),balance:(0,schema_1.baseNumberSchema)("Wallet balance"),transactions:{type:"array",description:"List of transactions",items:{type:"object",properties:exports.baseTransactionSchema,nullable:!0}},address:{type:"array",description:"Wallet addresses",items:(0,schema_1.baseStringSchema)("Wallet address"),nullable:!0}};const lockedAddressesCache=new Map;