"use strict";async function handleOrderBookBroadcast(e,r){try{if(!r){console.error("Book is undefined");return}const s=1e-10,t={asks:Object.entries(r.asks||{}).map(([e,r])=>[(0,blockchain_1.fromWei)(Number(e)),(0,blockchain_1.fromWei)(Number(r))]).filter(([e,r])=>e>s&&r>s),bids:Object.entries(r.bids||{}).map(([e,r])=>[(0,blockchain_1.fromWei)(Number(e)),(0,blockchain_1.fromWei)(Number(r))]).filter(([e,r])=>e>s&&r>s)};Websocket_1.messageBroker.broadcastToSubscribedClients("/api/ecosystem/market",{type:"orderbook",symbol:e},{stream:"orderbook",data:t})}catch(e){console.error(`Failed to fetch and broadcast order book: ${e}`)}}async function handleOrderBroadcast(e){const r={...e,price:(0,blockchain_1.fromBigInt)(e.price),amount:(0,blockchain_1.fromBigInt)(e.amount),filled:(0,blockchain_1.fromBigInt)(e.filled),remaining:(0,blockchain_1.fromBigInt)(e.remaining),cost:(0,blockchain_1.fromBigInt)(e.cost),fee:(0,blockchain_1.fromBigInt)(e.fee),average:(0,blockchain_1.fromBigInt)(e.average)};Websocket_1.messageBroker.broadcastToSubscribedClients("/api/ecosystem/order",{type:"orders",userId:e.userId},{stream:"orders",data:[r]})}async function handleTradesBroadcast(e,r){Websocket_1.messageBroker.broadcastToSubscribedClients("/api/ecosystem/market",{type:"trades",symbol:e},{stream:"trades",data:r})}async function handleTickerBroadcast(e,r){Websocket_1.messageBroker.broadcastToSubscribedClients("/api/ecosystem/market",{type:"ticker",symbol:e},{stream:"ticker",data:r})}async function handleCandleBroadcast(e,r,s){const t=[s.createdAt.getTime(),s.open,s.high,s.low,s.close,s.volume];Websocket_1.messageBroker.broadcastToSubscribedClients("/api/ecosystem/market",{type:"ohlcv",interval:r,symbol:e},{stream:`ohlcv:${r}`,data:[t]})}async function handleTickersBroadcast(e){Websocket_1.messageBroker.broadcastToSubscribedClients("/api/ecosystem/ticker",{type:"tickers"},{stream:"tickers",data:e})}function intervalToMs(e){const r=e.slice(-1),s=parseInt(e.slice(0,-1),10);return{m:6e4,h:36e5,d:864e5,w:6048e5}[r]*s}function normalizeTimeToInterval(e,r){const s=new Date(e);switch(r.slice(-1)){case"m":return(0,date_fns_1.startOfMinute)(s).getTime();case"h":return(0,date_fns_1.startOfHour)(s).getTime();case"d":return(0,date_fns_1.startOfDay)(s).getTime();case"w":return(0,date_fns_1.startOfWeek)(s,{weekStartsOn:1}).getTime();default:throw(0,error_1.createError)({statusCode:400,message:`Invalid interval: ${r}`})}}async function offloadToRedis(e,r){const s=JSON.stringify(r);await setAsync(e,s)}async function loadKeysFromRedis(e){try{return await keysAsync(e)}catch(e){console.error("Failed to fetch keys:",e);return[]}}async function loadFromRedis(e){const r=await getAsync(e);if(!r)return null;try{return JSON.parse(r)}catch(e){console.error("Failed to parse JSON:",e)}}async function removeFromRedis(e){try{await delAsync(e)}catch(e){console.error("Failed to delete key:",e)}}async function convertToOrderArray(e){const r=[];for(let s=0;s<e.length;s+=2)r.push([parseFloat(e[s]),parseFloat(e[s+1])]);return r}Object.defineProperty(exports,"__esModule",{value:!0});exports.handleOrderBookBroadcast=handleOrderBookBroadcast;exports.handleOrderBroadcast=handleOrderBroadcast;exports.handleTradesBroadcast=handleTradesBroadcast;exports.handleTickerBroadcast=handleTickerBroadcast;exports.handleCandleBroadcast=handleCandleBroadcast;exports.handleTickersBroadcast=handleTickersBroadcast;exports.intervalToMs=intervalToMs;exports.normalizeTimeToInterval=normalizeTimeToInterval;exports.offloadToRedis=offloadToRedis;exports.loadKeysFromRedis=loadKeysFromRedis;exports.loadFromRedis=loadFromRedis;exports.removeFromRedis=removeFromRedis;exports.convertToOrderArray=convertToOrderArray;const date_fns_1=require("date-fns"),redis_1=require("../../../../utils/redis"),Websocket_1=require("@b/handler/Websocket"),blockchain_1=require("./blockchain"),error_1=require("@b/utils/error"),redis=redis_1.RedisSingleton.getInstance(),setAsync=(e,r)=>redis.set(e,r),getAsync=e=>redis.get(e),delAsync=e=>redis.del(e),keysAsync=e=>redis.keys(e);