"use strict";async function updateOrderBookState(e,o){const t=["asks","bids"];try{await Promise.all(t.map(async t=>{for(const[r,n]of Object.entries(o[t])){const o=BigInt(n);if(e[t][r]){e[t][r]+=o;e[t][r]<=BigInt(0)&&delete e[t][r]}else e[t][r]=o>BigInt(0)?o:BigInt(0)}}))}catch(e){console_1.logger.error("ORDERBOOK","Failed to update order book state",e)}}function applyUpdatesToOrderBook(e,o){const t={bids:{...e.bids},asks:{...e.asks}};["bids","asks"].forEach(e=>{if(o[e]){for(const[r,n]of Object.entries(o[e]))if(null!=n)try{const o=BigInt(n);o>BigInt(0)?t[e][r]=o:delete t[e][r]}catch(e){console_1.logger.error("ORDERBOOK",`Error converting ${n} to BigInt`,e)}}else console_1.logger.warn("ORDERBOOK",`No updates for ${e}`)});return t}async function fetchExistingAmounts(e){try{const o=await client_1.default.execute("SELECT price, side, amount FROM orderbook_by_symbol WHERE symbol = ?;",[e]),t={bids:{},asks:{}};o.rows.forEach(e=>{const o="BIDS"===e.side?"bids":"asks",r=(0,blockchain_1.removeTolerance)((0,blockchain_1.toBigIntFloat)(e.price)).toString();t[o][r]=(0,blockchain_1.removeTolerance)((0,blockchain_1.toBigIntFloat)(e.amount))});return t}catch(o){console_1.logger.error("ORDERBOOK",`Failed to fetch existing amounts for ${e}`,o);throw(0,error_1.createError)({statusCode:500,message:`Failed to fetch existing amounts for ${e}`})}}async function updateSingleOrderBook(e,o){try{const t=await client_1.default.execute("SELECT price, side, amount FROM orderbook_by_symbol WHERE symbol = ?;",[e.symbol]),r={bids:{},asks:{}};t.rows.forEach(e=>{const o="BIDS"===e.side?"bids":"asks";r[o][(0,blockchain_1.removeTolerance)((0,blockchain_1.toBigIntFloat)(e.price)).toString()]=(0,blockchain_1.removeTolerance)((0,blockchain_1.toBigIntFloat)(e.amount))});const n="BUY"===e.side?"bids":"asks",i=(0,blockchain_1.removeTolerance)(BigInt(e.price)),a=r[n][i.toString()]||BigInt(0);let s=BigInt(0);"add"===o?s=a+(0,blockchain_1.removeTolerance)(BigInt(e.amount)):"subtract"===o&&(s=a-(0,blockchain_1.removeTolerance)(BigInt(e.amount)));if(s>BigInt(0)){await client_1.default.execute("INSERT INTO orderbook (symbol, price, side, amount) VALUES (?, ?, ?, ?)",[e.symbol,(0,blockchain_1.fromBigInt)(i),"BUY"===e.side?"BIDS":"ASKS",(0,blockchain_1.fromBigInt)(s)]);r[n][i.toString()]=s}else{await client_1.default.execute("DELETE FROM orderbook WHERE symbol = ? AND price = ? AND side = ?",[e.symbol,(0,blockchain_1.fromBigInt)(i),"BUY"===e.side?"BIDS":"ASKS"]);delete r[n][i.toString()]}return r}catch(e){console_1.logger.error("ORDERBOOK","Failed to update order book in database",e);throw(0,error_1.createError)({statusCode:500,message:"Failed to update order book in database"})}}function generateOrderBookUpdateQueries(e){const o=[];for(const[t,r]of Object.entries(e))for(const[e,n]of Object.entries(r))if(0!==Object.keys(n).length)for(const[r,i]of Object.entries(n))i>BigInt(0)?o.push({query:"UPDATE orderbook SET amount = ? WHERE symbol = ? AND price = ? AND side = ?",params:[(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(BigInt(i))),t,(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(BigInt(r))),e.toUpperCase()]}):o.push({query:"DELETE FROM orderbook WHERE symbol = ? AND price = ? AND side = ?",params:[t,(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(BigInt(r))),e.toUpperCase()]});else o.push({query:"DELETE FROM orderbook WHERE symbol = ? AND side = ?",params:[t,e.toUpperCase()]});return o}var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});exports.updateOrderBookState=updateOrderBookState;exports.applyUpdatesToOrderBook=applyUpdatesToOrderBook;exports.fetchExistingAmounts=fetchExistingAmounts;exports.updateSingleOrderBook=updateSingleOrderBook;exports.generateOrderBookUpdateQueries=generateOrderBookUpdateQueries;const blockchain_1=require("./blockchain"),client_1=__importDefault(require("./scylla/client")),console_1=require("@b/utils/console"),error_1=require("@b/utils/error");