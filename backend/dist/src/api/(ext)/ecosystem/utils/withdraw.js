"use strict";async function updatePrivateLedger(e,a,t,r,i){var o;const s=await getPrivateLedger(e,a,t,r),n=(null!==(o=null==s?void 0:s.offchainDifference)&&void 0!==o?o:0)+i,c=`${r}_NETWORK`,l=process.env[c];await db_1.models.ecosystemPrivateLedger.findOne({where:{walletId:e,index:a,currency:t,chain:r,network:l}})?await db_1.models.ecosystemPrivateLedger.update({offchainDifference:n},{where:{walletId:e,index:a,currency:t,chain:r,network:l}}):await db_1.models.ecosystemPrivateLedger.create({walletId:e,index:a,currency:t,chain:r,offchainDifference:n,network:l})}async function getPrivateLedger(e,a,t,r){const i=`${r}_NETWORK`,o=process.env[i];return await db_1.models.ecosystemPrivateLedger.findOne({where:{walletId:e,index:a,currency:t,chain:r,network:o}})}async function normalizePrivateLedger(e){const a=await getAllPrivateLedgersForWallet(e);let t=[],r=[];for(const e of a)e.offchainDifference>0?t.push(e):e.offchainDifference<0&&r.push(e);t=t.sort((e,a)=>a.offchainDifference-e.offchainDifference);r=r.sort((e,a)=>e.offchainDifference-a.offchainDifference);for(const e of t)for(const a of r){const t=Math.min(e.offchainDifference,-a.offchainDifference);if(0!==t){await db_1.models.ecosystemPrivateLedger.update({offchainDifference:e.offchainDifference-t},{where:{id:e.id}});await db_1.models.ecosystemPrivateLedger.update({offchainDifference:a.offchainDifference+t},{where:{id:a.id}});e.offchainDifference-=t;a.offchainDifference+=t;if(0===e.offchainDifference||0===a.offchainDifference)break}}}async function getAllPrivateLedgersForWallet(e){return await db_1.models.ecosystemPrivateLedger.findAll({where:{walletId:e}})}Object.defineProperty(exports,"__esModule",{value:!0});exports.handleEvmWithdrawal=void 0;exports.updatePrivateLedger=updatePrivateLedger;const db_1=require("@b/db"),chains_1=require("./chains"),utils_1=require("@b/utils"),console_1=require("@b/utils/console"),error_1=require("@b/utils/error"),wallet_1=require("@b/api/(ext)/ecosystem/utils/wallet"),provider_1=require("./provider"),ethers_1=require("ethers"),wallet_2=require("@b/services/wallet"),notification_1=require("@b/services/notification"),handleEvmWithdrawal=async(e,a,t,r,i)=>{console_1.logger.info("EVM_WITHDRAW",`Starting withdrawal: txId=${e}, wallet=${a}, chain=${t}, amount=${r}, to=${null==i?void 0:i.substring(0,10)}...`);(0,wallet_1.validateAddress)(i,t);console_1.logger.debug("EVM_WITHDRAW","Address validation passed");console_1.logger.debug("EVM_WITHDRAW",`Initializing provider for chain: ${t}`);const o=await(0,provider_1.initializeProvider)(t);console_1.logger.debug("EVM_WITHDRAW",`Fetching user wallet: ${a}`);const s=await db_1.models.wallet.findByPk(a);if(!s){console_1.logger.error("EVM_WITHDRAW",`User wallet not found: ${a}`);throw(0,error_1.createError)({statusCode:404,message:"User wallet not found"})}console_1.logger.debug("EVM_WITHDRAW",`Wallet found, currency: ${s.currency}`);const{currency:n}=s;console_1.logger.debug("EVM_WITHDRAW",`Initializing contracts for ${n} on ${t}`);const{contract:c,contractAddress:l,gasPayer:d,contractType:f,tokenDecimals:u}=await(0,wallet_1.initializeContracts)(t,n,o);console_1.logger.debug("EVM_WITHDRAW",`Contract details: type=${f}, address=${l}, decimals=${u}`);const w=ethers_1.ethers.parseUnits(r.toString(),u);console_1.logger.debug("EVM_WITHDRAW",`Amount in wei: ${w.toString()}`);let g,_,h,m,W;if("PERMIT"===f){console_1.logger.debug("EVM_WITHDRAW","Processing PERMIT contract type");g=await(0,wallet_1.getWalletData)(a,t);const e=await(0,wallet_1.getAndValidateTokenOwner)(g,w,c,o);_=e.actualTokenOwner;h=e.alternativeWalletUsed;W=e.alternativeWallet;try{await(0,wallet_1.executePermit)(c,l,d,_,w,o)}catch(e){console_1.logger.error("EVM_WITHDRAW","Failed to execute permit",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to execute permit: ${e.message}`})}try{m=await(0,wallet_1.executeEcosystemWithdrawal)(c,l,d,_,i,w,o)}catch(e){console_1.logger.error("EVM_WITHDRAW",`Failed to execute withdrawal: ${e.message}`);throw(0,error_1.createError)({statusCode:500,message:`Failed to execute withdrawal: ${e.message}`})}}else if("NO_PERMIT"===f){const e=chains_1.chainConfigs[t].currency===n;try{m=await(0,wallet_1.executeNoPermitWithdrawal)(t,l,d,i,w,o,e)}catch(e){console_1.logger.error("EVM_WITHDRAW",`Failed to execute withdrawal: ${e.message}`);throw(0,error_1.createError)({statusCode:500,message:`Failed to execute withdrawal: ${e.message}`})}}else if("NATIVE"===f)try{g=await(0,wallet_1.getWalletData)(a,t);const e=await(0,wallet_1.getAndValidateNativeTokenOwner)(g,w,o);m=await(0,wallet_1.executeNativeWithdrawal)(e,i,w,o)}catch(e){console_1.logger.error("EVM_WITHDRAW",`Failed to execute withdrawal: ${e.message}`);throw(0,error_1.createError)({statusCode:500,message:`Failed to execute withdrawal: ${e.message}`})}if(m&&m.hash){let s=0;const c=10;for(;s<c;)try{const c=await o.getTransactionReceipt(m.hash);if(c&&1===c.status){console_1.logger.success("EVM_WITHDRAW",`Transaction confirmed: ${m.hash}`);if("PERMIT"===f){if(h){await(0,wallet_1.updateAlternativeWallet)(n,t,r);await updatePrivateLedger(W.walletId,W.index,n,t,r)}await updatePrivateLedger(a,g.index,n,t,-r)}else if("NATIVE"===f)try{const r=await o.getTransaction(m.hash),i=(null==r?void 0:r.gasPrice)||ethers_1.ethers.parseUnits("0","gwei"),s=c.gasUsed*i,l=parseFloat(ethers_1.ethers.formatUnits(s,u));console_1.logger.debug("EVM_WITHDRAW",`NATIVE gas reconciliation: gasUsed=${c.gasUsed}, gasPrice=${i}, actualGasFee=${l}, txHash=${m.hash}`);const d=await db_1.models.transaction.findByPk(e);if(d&&d.fee){const r=parseFloat(d.fee),i=r-l;console_1.logger.debug("EVM_WITHDRAW",`Gas fee comparison: estimated=${r}, actual=${l}, difference=${i}`);if(Math.abs(i)>1e-8){const o=await db_1.models.wallet.findByPk(a);if(o){const a=`eco_gas_reconcile_${e}`;i>0?await wallet_2.walletService.ecoRefund({idempotencyKey:a,userId:o.userId,walletId:o.id,currency:n,chain:t,amount:i,operationType:"ECO_REFUND",referenceId:e,description:`Gas fee refund - overestimated by ${i} ${n}`,metadata:{transactionId:e,estimatedGasFee:r,actualGasFee:l,reason:"gas_overestimate"}}):await wallet_2.walletService.ecoDebit({idempotencyKey:a,userId:o.userId,walletId:o.id,currency:n,chain:t,amount:Math.abs(i),operationType:"ECO_WITHDRAW",referenceId:e,description:`Gas fee adjustment - underestimated by ${Math.abs(i)} ${n}`,metadata:{transactionId:e,estimatedGasFee:r,actualGasFee:l,reason:"gas_underestimate"}});console_1.logger.info("EVM_WITHDRAW",`Adjusted wallet balance by ${i} ${n}`)}}}}catch(e){console_1.logger.error("EVM_WITHDRAW","Failed to reconcile gas fee",e)}await db_1.models.transaction.update({status:"COMPLETED",description:`Withdrawal of ${r} ${n} to ${i}`,trxId:m.hash},{where:{id:e}});console_1.logger.success("EVM_WITHDRAW","Transaction marked as COMPLETED");return!0}s+=1;await(0,utils_1.delay)(5e3)}catch(e){console_1.logger.error("EVM_WITHDRAW",`Failed to check transaction status: ${e.message}`);try{const e=await db_1.models.user.findAll({include:[{model:db_1.models.role,as:"role",where:{name:["Admin","Super Admin"]}}],attributes:["id"]});for(const a of e)await notification_1.notificationService.send({userId:a.id,type:"ALERT",channels:["IN_APP"],idempotencyKey:`evm_withdraw_issue_${m.hash}_${a.id}_${s}`,data:{title:"Ecosystem Withdrawal Issue",message:`Failed to verify withdrawal transaction ${m.hash}. Manual review required.`,link:"/admin/ecosystem/wallet/custodial"},priority:"HIGH"})}catch(e){console_1.logger.error("EVM_WITHDRAW","Failed to send admin notification",e)}s+=1;await(0,utils_1.delay)(5e3)}console_1.logger.error("EVM_WITHDRAW",`Transaction ${m.hash} failed after ${c} attempts.`)}throw(0,error_1.createError)({statusCode:500,message:"Transaction failed"})};exports.handleEvmWithdrawal=handleEvmWithdrawal;