"use strict";async function recordBotRealTrade(e,r,t,o,a,i){try{const r=await db_1.models.aiBot.findByPk(e);if(!r){console_1.logger.warn("BOT_PNL",`Bot ${e} not found, skipping trade recording`);return}const t=r.get({plain:!0}),s=Number(t.currentPosition||0),n=Number(t.avgEntryPrice||0);let l=s,d=n,c=0,u=!1;if("BUY"===o)if(s<0){const e=Math.min(i,Math.abs(s));c=(n-a)*e;u=c>0;const r=i-e;if(r>0){l=r;d=a}else l=s+i}else{l=s+i;d=l>0?(s*n+i*a)/l:0}else if(s>0){const e=Math.min(i,s);c=(a-n)*e;u=c>0;const r=i-e;if(r>0){l=-r;d=a}else l=s-i}else{const e=Math.abs(s)*n+i*a;l=s-i;d=0!==l?e/Math.abs(l):0}const f={currentPosition:l,avgEntryPrice:d,realTradesExecuted:(t.realTradesExecuted||0)+1,totalVolume:(Number(t.totalVolume)||0)+i,lastTradeAt:new Date};if(0!==c){f.totalRealizedPnL=(Number(t.totalRealizedPnL)||0)+c;u&&(f.profitableTrades=(t.profitableTrades||0)+1)}await r.update(f);console_1.logger.info("BOT_PNL",`Bot ${e} ${o} ${i.toFixed(4)} @ ${a.toFixed(6)} | Position: ${s.toFixed(4)} -> ${l.toFixed(4)} | PnL: ${c.toFixed(4)} | Profitable: ${u}`)}catch(r){console_1.logger.error("BOT_PNL",`Failed to record trade for bot ${e}`,r)}}function isBotOrder(e){return!!e.marketMakerId}async function getPoolForMarketMaker(e){return await db_1.models.aiMarketMakerPool.findOne({where:{marketMakerId:e}})}async function updatePoolBalance(e,r,t){const o=await getPoolForMarketMaker(e);if(!o)throw(0,error_1.createError)({statusCode:404,message:`Pool not found for market maker ${e}`});const a=o,i=Number(a.baseCurrencyBalance)+r,s=Number(a.quoteCurrencyBalance)+t;if(i<0)throw(0,error_1.createError)({statusCode:400,message:`Insufficient pool base balance: need ${Math.abs(r)}, have ${a.baseCurrencyBalance}`});if(s<0)throw(0,error_1.createError)({statusCode:400,message:`Insufficient pool quote balance: need ${Math.abs(t)}, have ${a.quoteCurrencyBalance}`});await o.update({baseCurrencyBalance:i,quoteCurrencyBalance:s})}function isAiSystemUser(e){return!!AI_SYSTEM_USER_IDS.includes(e)||!(!e.startsWith("00000000-0000-0000")&&!e.startsWith("a1000000-0000-4000"))}async function processMatchedOrders(e,r,t,o){var a,i,s,n;const l=e.remaining<r.remaining?e.remaining:r.remaining;[e,r].forEach(e=>{e.filled+=l;e.remaining-=l;e.status=e.remaining===BigInt(0)?"CLOSED":"OPEN"});const[d,c]=e.symbol.split("/"),u=isBotOrder(e),f=isBotOrder(r),g="MARKET"===e.type.toUpperCase()?r.price:"MARKET"===r.type.toUpperCase()||e.createdAt<=r.createdAt?e.price:r.price,_=l*g/SCALING_FACTOR,m=Number(l)/Number(e.amount),y=Number(l)/Number(r.amount),p=r.fee*BigInt(Math.floor(1e18*y))/SCALING_FACTOR,b=e.fee*BigInt(Math.floor(1e18*m))/SCALING_FACTOR,I=_+b,h=(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(l)),B=(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(_)),O=(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(p)),T=(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(I));if(u&&f);else if(u&&!f){const t=r.walletType||"ECO",o=await getUserEcosystemWalletByCurrency(r.userId,d,t),i=await getUserEcosystemWalletByCurrency(r.userId,c,t);if(!o||!i)throw(0,error_1.createError)({statusCode:404,message:`Wallets not found for seller ${r.userId} (type: ${t})`});const s=parseFloat((null===(a=o.inOrder)||void 0===a?void 0:a.toString())||"0");if(s+1e-8<h){console_1.logger.error("MATCHING",`Seller insufficient locked funds: inOrder=${s}, needed=${h}, walletType=${t}`);throw(0,error_1.createError)({statusCode:400,message:"Seller has insufficient locked funds"})}const n=Math.min(h,s);await updatePoolBalance(e.marketMakerId,h,-B);const l=`eco_trade_${e.id}_${r.id}_seller_base`,u=`eco_trade_${e.id}_${r.id}_seller_quote`;await(0,wallet_1.updateWalletForFill)(o,0,-n,"seller releases base to bot",l);await(0,wallet_1.updateWalletForFill)(i,B-O,0,"seller receives quote from bot",u);if(e.botId){const t=(0,blockchain_1.fromBigInt)(g);recordBotRealTrade(e.botId,void 0,e.symbol,"BUY",t,h,r.userId).catch(e=>console_1.logger.error("BOT_PNL","Error recording bot trade",e))}}else if(!u&&f){const t=e.walletType||"ECO",o=await getUserEcosystemWalletByCurrency(e.userId,d,t),a=await getUserEcosystemWalletByCurrency(e.userId,c,t);if(!o||!a)throw(0,error_1.createError)({statusCode:404,message:`Wallets not found for buyer ${e.userId} (type: ${t})`});const s=parseFloat((null===(i=a.inOrder)||void 0===i?void 0:i.toString())||"0"),n=1e-8;console_1.logger.info("MATCHING",`User vs Bot match: orderId=${e.id}, userId=${e.userId}, walletType=${t}, amountToFill=${h}, buyFillRatio=${m.toFixed(4)}, buyOrder.cost=${(0,blockchain_1.fromBigInt)(e.cost)}, buyReleaseNum=${T}, buyerInOrder=${s}, buyOrder.status=${e.status}, buyOrder.remaining=${(0,blockchain_1.fromBigInt)(e.remaining)}`);if(s+n<T){console_1.logger.error("MATCHING",`Buyer insufficient locked funds: inOrder=${s}, needed=${T}, diff=${T-s}, orderId=${e.id}, walletType=${t}`);throw(0,error_1.createError)({statusCode:400,message:"Buyer has insufficient locked funds"})}const l=Math.min(T,s);await updatePoolBalance(r.marketMakerId,-h,B);const u=`eco_trade_${e.id}_${r.id}_buyer_base`,f=`eco_trade_${e.id}_${r.id}_buyer_quote`;await(0,wallet_1.updateWalletForFill)(o,h,0,"buyer receives base from bot",u);await(0,wallet_1.updateWalletForFill)(a,0,-l,"buyer releases quote to bot",f);if(r.botId){const t=(0,blockchain_1.fromBigInt)(g);recordBotRealTrade(r.botId,void 0,r.symbol,"SELL",t,h,e.userId).catch(e=>console_1.logger.error("BOT_PNL","Error recording bot trade",e))}}else{const t=e.walletType||"ECO",o=r.walletType||"ECO",a=await getUserEcosystemWalletByCurrency(e.userId,d,t),i=await getUserEcosystemWalletByCurrency(e.userId,c,t),l=await getUserEcosystemWalletByCurrency(r.userId,d,o),u=await getUserEcosystemWalletByCurrency(r.userId,c,o);if(!(a&&i&&l&&u))throw(0,error_1.createError)({statusCode:404,message:`Required wallets not found for buyer (type: ${t}) or seller (type: ${o}).`});const f=1e-8,g=parseFloat((null===(s=l.inOrder)||void 0===s?void 0:s.toString())||"0");if(g+f<h){console_1.logger.error("MATCHING",`Seller insufficient locked funds: inOrder=${g}, needed=${h}, walletType=${o}`);throw(0,error_1.createError)({statusCode:400,message:"Seller has insufficient locked funds"})}const _=Math.min(h,g),m=parseFloat((null===(n=i.inOrder)||void 0===n?void 0:n.toString())||"0");if(m+f<T){console_1.logger.error("MATCHING",`Buyer insufficient locked funds: inOrder=${m}, needed=${T}, walletType=${t}`);throw(0,error_1.createError)({statusCode:400,message:"Buyer has insufficient locked funds"})}const y=Math.min(T,m),p=`eco_trade_${e.id}_${r.id}_buy_base`,b=`eco_trade_${e.id}_${r.id}_buy_quote`,I=`eco_trade_${e.id}_${r.id}_sell_base`,w=`eco_trade_${e.id}_${r.id}_sell_quote`;await(0,wallet_1.updateWalletForFill)(a,h,0,"buyer receives base",p);await(0,wallet_1.updateWalletForFill)(i,0,-y,"buyer releases quote",b);await(0,wallet_1.updateWalletForFill)(l,0,-_,"seller releases base",I);await(0,wallet_1.updateWalletForFill)(u,B-O,0,"seller receives quote",w)}const w={id:`${e.id}`,amount:(0,blockchain_1.fromBigInt)(l),price:(0,blockchain_1.fromBigInt)(g),cost:(0,blockchain_1.fromBigIntMultiply)(l,g),side:"BUY",timestamp:Date.now()},E={id:`${r.id}`,amount:(0,blockchain_1.fromBigInt)(l),price:(0,blockchain_1.fromBigInt)(g),cost:(0,blockchain_1.fromBigIntMultiply)(l,g),side:"SELL",timestamp:Date.now()};addTradeToOrder(e,w);addTradeToOrder(r,E);(0,queries_1.insertTrade)(e.symbol,w.price,w.amount,"BUY",!1).catch(e=>console_1.logger.error("MATCHING","Failed to insert trade to trades table",e));(0,ws_1.handleTradesBroadcast)(e.symbol,[w,E]);(0,ws_1.handleOrderBroadcast)(e);(0,ws_1.handleOrderBroadcast)(r);updateOrderBook(o,e,t,l);updateOrderBook(o,r,t,l);triggerCopyTradingFill(e.id,e.userId,e.symbol,e.side,(0,blockchain_1.fromBigInt)(l),(0,blockchain_1.fromBigInt)(g),(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(b)),"CLOSED"===e.status?"FILLED":"PARTIALLY_FILLED");triggerCopyTradingFill(r.id,r.userId,r.symbol,r.side,(0,blockchain_1.fromBigInt)(l),(0,blockchain_1.fromBigInt)(g),(0,blockchain_1.fromBigInt)((0,blockchain_1.removeTolerance)(p)),"CLOSED"===r.status?"FILLED":"PARTIALLY_FILLED")}function addTradeToOrder(e,r){let t=[];if(e.trades)try{if("string"==typeof e.trades){t=JSON.parse(e.trades);Array.isArray(t)||"string"!=typeof t||(t=JSON.parse(t))}else if(Array.isArray(e.trades))t=e.trades;else{console_1.logger.error("MATCHING",`Invalid trades format, resetting trades: ${JSON.stringify(e.trades)}`,new Error("Invalid trades format"));t=[]}}catch(e){console_1.logger.error("MATCHING","Error parsing trades",e);t=[]}const o=[...t,r].sort((e,r)=>e.timestamp-r.timestamp);e.trades=JSON.stringify(o,blockchain_1.BigIntReplacer);return e.trades}function validateOrder(e){if(!(e&&e.id&&e.userId&&e.symbol&&e.type&&e.side&&"bigint"==typeof e.price&&"bigint"==typeof e.amount&&"bigint"==typeof e.filled&&"bigint"==typeof e.remaining&&"bigint"==typeof e.cost&&"bigint"==typeof e.fee&&e.feeCurrency&&e.status&&e.createdAt instanceof Date&&e.updatedAt instanceof Date)){console_1.logger.error("MATCHING","Order validation failed",new Error(`Order validation failed: ${JSON.stringify(e)}`));return!1}return!0}function sortOrders(e,r){return e.sort((e,t)=>{const o=Number(r?t.price-e.price:e.price-t.price);return 0!==o?o:e.createdAt<t.createdAt?-1:e.createdAt>t.createdAt?1:0})}async function getUserEcosystemWalletByCurrency(e,r,t="ECO"){try{const o=await db_1.models.wallet.findOne({where:{userId:e,currency:r,type:t},raw:!1});if(!o)throw(0,error_1.createError)({statusCode:404,message:`Wallet not found for user ${e} and currency ${r} (type: ${t})`});return o}catch(e){console_1.logger.error("ECOSYSTEM","Failed to get user ecosystem wallet by currency",e);throw e}}async function triggerCopyTradingFill(e,r,t,o,a,i,s,n){try{const{triggerCopyTradingOrderFilled:l}=await Promise.resolve().then(()=>__importStar(require("@b/utils/safe-imports")));l(e,r,t,o,a,i,s,n).catch(()=>{})}catch(e){}}var __createBinding=this&&this.__createBinding||(Object.create?function(e,r,t,o){void 0===o&&(o=t);var a=Object.getOwnPropertyDescriptor(r,t);a&&!("get"in a?!r.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return r[t]}});Object.defineProperty(e,o,a)}:function(e,r,t,o){void 0===o&&(o=t);e[o]=r[t]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),__importStar=this&&this.__importStar||function(){var e=function(r){e=Object.getOwnPropertyNames||function(e){var r=[];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[r.length]=t);return r};return e(r)};return function(r){if(r&&r.__esModule)return r;var t={};if(null!=r)for(var o=e(r),a=0;a<o.length;a++)"default"!==o[a]&&__createBinding(t,r,o[a]);__setModuleDefault(t,r);return t}}();Object.defineProperty(exports,"__esModule",{value:!0});exports.filterAndSortOrders=exports.matchAndCalculateOrders=void 0;exports.processMatchedOrders=processMatchedOrders;exports.addTradeToOrder=addTradeToOrder;exports.validateOrder=validateOrder;exports.sortOrders=sortOrders;exports.getUserEcosystemWalletByCurrency=getUserEcosystemWalletByCurrency;const db_1=require("@b/db"),blockchain_1=require("./blockchain"),queries_1=require("./scylla/queries"),wallet_1=require("./wallet"),ws_1=require("./ws"),console_1=require("@b/utils/console"),error_1=require("@b/utils/error"),SCALING_FACTOR=BigInt(10**18),AI_SYSTEM_USER_IDS=["a1000000-0000-4000-a000-000000000001","00000000-0000-0000-0000-000000000001","00000000-0000-0000-0000-000000000000"];let aiUserErrorCount=0,lastAiUserErrorTime=0;const AI_ERROR_LOG_INTERVAL=6e4,matchAndCalculateOrders=async(e,r)=>{const t=[],o={bids:{},asks:{}},a=new Set,i=(0,exports.filterAndSortOrders)(e,"BUY",!0),s=(0,exports.filterAndSortOrders)(e,"SELL",!1);let n=0,l=0;for(;n<i.length&&l<s.length;){const e=i[n],d=s[l];if(a.has(e.id)||a.has(d.id)){a.has(e.id)&&n++;a.has(d.id)&&l++;continue}let c=!1;"LIMIT"===e.type&&"LIMIT"===d.type?c="BUY"===e.side&&e.price>=d.price||"SELL"===e.side&&d.price>=e.price:"MARKET"!==e.type&&"MARKET"!==d.type||(c=!0);if(c){a.add(e.id);a.add(d.id);try{await processMatchedOrders(e,d,r,o);t.push(e,d)}catch(r){const t=String(r),o=AI_SYSTEM_USER_IDS.some(e=>t.includes(e)),i=isAiSystemUser(e.userId)||isAiSystemUser(d.userId),s=t.includes("Wallet not found for user"),c=t.includes("insufficient locked funds");if(o||i||s&&t.includes("00000000")){aiUserErrorCount++;const e=Date.now();if(e-lastAiUserErrorTime>6e4){console_1.logger.warn("MATCHING",`System/AI user wallet errors: ${aiUserErrorCount} in the last minute. Suppressing to reduce log noise.`);lastAiUserErrorTime=e;aiUserErrorCount=0}}else c||console_1.logger.error("MATCHING","Failed to process matched orders",r);if(c||s){n++;l++}else{a.delete(e.id);a.delete(d.id)}continue}"LIMIT"===e.type&&e.remaining===BigInt(0)&&n++;"LIMIT"===d.type&&d.remaining===BigInt(0)&&l++;"MARKET"===e.type&&e.remaining>BigInt(0)&&a.delete(e.id);"MARKET"===d.type&&d.remaining>BigInt(0)&&a.delete(d.id)}else{"MARKET"!==e.type&&BigInt(e.price)<BigInt(d.price)&&n++;"MARKET"!==d.type&&BigInt(d.price)>BigInt(e.price)&&l++}}return{matchedOrders:t,bookUpdates:o}};exports.matchAndCalculateOrders=matchAndCalculateOrders;const updateOrderBook=(e,r,t,o)=>{const a=r.price.toString(),i="BUY"===r.side?"bids":"asks";if(void 0!==t[i][a]){t[i][a]-=o;e[i][a]=t[i][a]}else e[i][a]=BigInt(0)},filterAndSortOrders=(e,r,t)=>e.filter(e=>e.side===r).sort((e,r)=>t?Number(r.price)-Number(e.price)||e.createdAt.getTime()-r.createdAt.getTime():Number(e.price)-Number(r.price)||e.createdAt.getTime()-r.createdAt.getTime()).filter(e=>!t||BigInt(e.price)>=BigInt(0));exports.filterAndSortOrders=filterAndSortOrders;