"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),gateway_1=require("@b/utils/gateway");exports.metadata={summary:"Create a refund for a payment",description:"Creates a refund for a completed payment. Merchants can issue full or partial refunds.",operationId:"merchantCreateRefund",tags:["Gateway","Merchant","Refund"],parameters:[{name:"id",in:"path",required:!0,description:"Payment intent ID (pi_xxx)",schema:{type:"string"}}],requestBody:{required:!1,content:{"application/json":{schema:{type:"object",properties:{amount:{type:"number",description:"Refund amount. If not provided, full remaining amount will be refunded."},reason:{type:"string",enum:["REQUESTED_BY_CUSTOMER","DUPLICATE","FRAUDULENT","OTHER"],description:"Reason for refund"},description:{type:"string",description:"Internal description for the refund"}}}}}},responses:{201:{description:"Refund created successfully"},400:{description:"Invalid request or payment cannot be refunded"},401:{description:"Unauthorized"},404:{description:"Payment not found"}},requiresAuth:!0,logModule:"GATEWAY",logTitle:"Create Payment Refund"};exports.default=async e=>{const{user:t,params:n,body:a,ctx:r}=e,{id:o}=n;null==r||r.step("Validate user authentication");if(!(null==t?void 0:t.id)){null==r||r.fail("Unauthorized - no user ID");throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"})}null==r||r.step("Find merchant account");const s=await db_1.models.gatewayMerchant.findOne({where:{userId:t.id}});if(!s){null==r||r.fail("Merchant account not found");throw(0,error_1.createError)({statusCode:404,message:"Merchant account not found"})}null==r||r.step("Validate merchant status");if("ACTIVE"!==s.status){null==r||r.fail("Merchant account is not active");throw(0,error_1.createError)({statusCode:403,message:"Merchant account is not active. Cannot process refunds."})}null==r||r.step("Find payment to refund");const d=await db_1.models.gatewayPayment.findOne({where:{paymentIntentId:o,merchantId:s.id}});if(!d){null==r||r.fail("Payment not found");throw(0,error_1.createError)({statusCode:404,message:"Payment not found"})}null==r||r.step("Validate payment can be refunded");if("COMPLETED"!==d.status&&"PARTIALLY_REFUNDED"!==d.status)throw(0,error_1.createError)({statusCode:400,message:`Payment with status ${d.status} cannot be refunded`});if(void 0!==(null==a?void 0:a.amount)){const e=parseFloat(a.amount);if(!Number.isFinite(e)||e<=0){null==r||r.fail("Invalid refund amount");throw(0,error_1.createError)({statusCode:400,message:"Refund amount must be a positive number"})}}null==r||r.step("Generate refund ID");const u=(0,gateway_1.generateRefundId)();null==r||r.step("Process refund in transaction");const i=await db_1.sequelize.transaction(async e=>{const t=await db_1.models.gatewayPayment.findByPk(d.id,{transaction:e,lock:e.LOCK.UPDATE});if(!t)throw(0,error_1.createError)({statusCode:404,message:"Payment not found"});if("COMPLETED"!==t.status&&"PARTIALLY_REFUNDED"!==t.status)throw(0,error_1.createError)({statusCode:400,message:`Payment with status ${t.status} cannot be refunded`});const n=(await db_1.models.gatewayRefund.findAll({where:{paymentId:t.id,status:"COMPLETED"},transaction:e})).reduce((e,t)=>e+parseFloat(t.amount),0),o=t.amount-n,i=(null==a?void 0:a.amount)?parseFloat(a.amount):o;if(i<=0)throw(0,error_1.createError)({statusCode:400,message:"Refund amount must be greater than 0"});if(i>o)throw(0,error_1.createError)({statusCode:400,message:`Refund amount ${i.toFixed(2)} exceeds remaining refundable amount ${o.toFixed(2)}`});const c=i*(t.feeAmount/t.amount),l=await db_1.models.gatewayRefund.create({paymentId:t.id,merchantId:s.id,refundId:u,amount:i,currency:t.currency,reason:(null==a?void 0:a.reason)||"REQUESTED_BY_CUSTOMER",description:(null==a?void 0:a.description)||null,status:"COMPLETED",metadata:null},{transaction:e});if(t.customerId&&!t.testMode){const n=t.allocations||[];if(0===n.length)throw(0,error_1.createError)({statusCode:400,message:"Payment has no allocation data for refund processing"});const a=await(0,gateway_1.processMultiWalletRefund)({userId:t.customerId,merchantUserId:s.userId,merchantId:s.id,paymentCurrency:t.currency,allocations:n,refundAmount:i,totalPaymentAmount:t.amount,feeAmount:c,refundId:l.id,paymentId:t.paymentIntentId,description:`Refund for payment ${t.paymentIntentId}`,transaction:e});await l.update({transactionId:a.userTransaction.id},{transaction:e})}const m=n+i>=t.amount?"REFUNDED":"PARTIALLY_REFUNDED";await t.update({status:m},{transaction:e});null==r||r.success("Refund created successfully");return{refund:l,refundAmount:i,lockedPayment:t}});null==r||r.step("Send refund completion webhook");if(i.lockedPayment.webhookUrl)try{await(0,gateway_1.sendWebhook)(s.id,i.lockedPayment.id,i.refund.id,"refund.completed",i.lockedPayment.webhookUrl,{id:`evt_${u}`,type:"refund.completed",createdAt:(new Date).toISOString(),data:{id:u,paymentId:i.lockedPayment.paymentIntentId,merchantOrderId:i.lockedPayment.merchantOrderId,amount:i.refundAmount,currency:i.lockedPayment.currency,status:"COMPLETED",reason:(null==a?void 0:a.reason)||"REQUESTED_BY_CUSTOMER"}},s.webhookSecret)}catch(e){console.error("Failed to send refund.completed webhook:",e)}null==r||r.success("Refund created successfully");return{id:u,paymentId:i.lockedPayment.paymentIntentId,amount:i.refundAmount,currency:i.lockedPayment.currency,status:"COMPLETED",reason:(null==a?void 0:a.reason)||"REQUESTED_BY_CUSTOMER",description:(null==a?void 0:a.description)||null,createdAt:i.refund.createdAt}};