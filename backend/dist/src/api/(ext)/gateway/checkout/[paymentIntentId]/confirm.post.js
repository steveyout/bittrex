"use strict";async function getPriceInUSD(e,t){try{return"FIAT"===t?await(0,utils_1.getFiatPriceInUSD)(e):"SPOT"===t?await(0,utils_1.getSpotPriceInUSD)(e):"ECO"===t?await(0,utils_1.getEcoPriceInUSD)(e):0}catch(e){return 0}}function roundAmount(e){return Math.round(1e8*e)/1e8}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),gateway_1=require("@b/utils/gateway"),utils_1=require("@b/api/finance/currency/utils"),console_1=require("@b/utils/console"),wallet_1=require("@b/services/wallet");exports.metadata={summary:"Confirm payment",description:"Confirms the payment and processes the transaction from customer wallet(s). Always uses allocation-based payments.",operationId:"confirmPayment",tags:["Gateway","Checkout"],parameters:[{name:"paymentIntentId",in:"path",required:!0,description:"Payment intent ID",schema:{type:"string"}}],requestBody:{required:!0,content:{"application/json":{schema:{type:"array",description:"Payment allocations - which wallets to use and how much from each",items:{type:"object",properties:{walletId:{type:"string"},walletType:{type:"string"},currency:{type:"string"},amount:{type:"number"},equivalentInPaymentCurrency:{type:"number"}},required:["walletId","walletType","currency","amount","equivalentInPaymentCurrency"]}}}}},responses:{200:{description:"Payment confirmed successfully"},400:{description:"Payment cannot be confirmed"},401:{description:"Authentication required"},402:{description:"Insufficient funds"}},requiresAuth:!0,logModule:"GATEWAY",logTitle:"Confirm Checkout Payment"};exports.default=async e=>{var t,r;const{params:a,user:n,body:o,headers:s,ctx:i}=e,{paymentIntentId:c}=a;null==i||i.step("Validate user authentication");if(!(null==n?void 0:n.id)){null==i||i.fail("Authentication required - no user ID");throw(0,error_1.createError)({statusCode:401,message:"Authentication required"})}null==i||i.step("Find payment session");const l=await db_1.models.gatewayPayment.findOne({where:{paymentIntentId:c},include:[{model:db_1.models.gatewayMerchant,as:"merchant"}]});if(!l){null==i||i.fail("Payment not found");throw(0,error_1.createError)({statusCode:404,message:"Payment not found"})}null==i||i.step("Verify payment authorization and status");if(l.customerId&&l.customerId!==n.id){null==i||i.fail("Not authorized to confirm this payment");throw(0,error_1.createError)({statusCode:403,message:"Not authorized to confirm this payment"})}if("PENDING"!==l.status&&"PROCESSING"!==l.status){null==i||i.fail(`Payment is already ${l.status.toLowerCase()}`);throw(0,error_1.createError)({statusCode:400,message:`Payment is already ${l.status.toLowerCase()}`})}if(new Date(l.expiresAt)<new Date){await l.update({status:"EXPIRED"});throw(0,error_1.createError)({statusCode:400,message:"Payment session has expired"})}if("ACTIVE"!==(null===(t=l.merchant)||void 0===t?void 0:t.status)){null==i||i.fail("Merchant is not active");throw(0,error_1.createError)({statusCode:400,message:"Merchant is not active"})}null==i||i.step("Validate payment allocations");const u=(await(0,gateway_1.getGatewaySettings)()).gatewayAllowedWalletTypes||{},d=Array.isArray(o)?o:[];if(0===d.length){null==i||i.fail("No payment allocations provided");throw(0,error_1.createError)({statusCode:400,message:"No payment allocations provided"})}for(const e of d){if(!Number.isFinite(e.amount)||e.amount<=0)throw(0,error_1.createError)({statusCode:400,message:"Invalid allocation amount: must be a positive number"});if(!Number.isFinite(e.equivalentInPaymentCurrency)||e.equivalentInPaymentCurrency<=0)throw(0,error_1.createError)({statusCode:400,message:"Invalid equivalent amount"})}const m=!0===l.testMode;null==i||i.step("Process payment in database transaction");try{const e=await db_1.sequelize.transaction(async e=>{var t;const r=await db_1.models.gatewayPayment.findByPk(l.id,{transaction:e,lock:e.LOCK.UPDATE});if(!r||"PENDING"!==r.status&&"PROCESSING"!==r.status)throw(0,error_1.createError)({statusCode:400,message:"Payment is no longer available for processing"});await r.update({status:"PROCESSING"},{transaction:e});const a=[];let o=0;const i=await getPriceInUSD(l.currency,l.walletType);if(!i||i<=0)throw(0,error_1.createError)({statusCode:400,message:`Could not determine price for payment currency ${l.currency}`});for(const t of d){const r=roundAmount(t.amount),s=u[t.walletType];if(!s||!s.enabled)throw(0,error_1.createError)({statusCode:400,message:`Wallet type ${t.walletType} is not enabled for payments`});if(!s.currencies||!s.currencies.includes(t.currency))throw(0,error_1.createError)({statusCode:400,message:`Currency ${t.currency} is not enabled for ${t.walletType} wallet payments`});const c=await db_1.models.wallet.findOne({where:{id:t.walletId,userId:n.id,currency:t.currency,type:t.walletType},transaction:e,lock:e.LOCK.UPDATE});if(!c)throw(0,error_1.createError)({statusCode:400,message:`Wallet not found: ${t.walletType} ${t.currency}`});const d=parseFloat(c.balance);if(d<r)throw(0,error_1.createError)({statusCode:402,message:`Insufficient funds in ${t.currency} wallet. Required: ${r}, Available: ${d}`});const y=await getPriceInUSD(t.currency,t.walletType);if(!y||y<=0)throw(0,error_1.createError)({statusCode:400,message:`Could not determine price for ${t.currency}`});const p=y/i,w=r*p,h=.02;if(Math.abs(t.equivalentInPaymentCurrency-w)/w>h)throw(0,error_1.createError)({statusCode:400,message:`Exchange rate has changed for ${t.currency}. Please refresh and try again.`});if(!m){const o=`gateway_payment_${l.paymentIntentId}_${t.walletId}_${a.length}`,s=await wallet_1.walletService.debit({idempotencyKey:o,userId:n.id,walletId:c.id,walletType:t.walletType,currency:t.currency,amount:r,operationType:"PAYMENT",referenceId:`${l.id}_${a.length}`,description:`Payment to ${l.merchant.name}${l.description?` - ${l.description}`:""} (${t.equivalentInPaymentCurrency.toFixed(2)} ${l.currency})`,metadata:{paymentIntentId:l.paymentIntentId,merchantId:l.merchant.id,merchantName:l.merchant.name,merchantOrderId:l.merchantOrderId,equivalentAmount:t.equivalentInPaymentCurrency,paymentCurrency:l.currency,exchangeRate:p},transaction:e});a.push({id:s.transactionId})}o+=t.equivalentInPaymentCurrency}if(o<l.amount-.01)throw(0,error_1.createError)({statusCode:402,message:`Insufficient payment. Required: ${l.amount} ${l.currency}, Allocated: ${o.toFixed(2)} ${l.currency}`});if(!m){const t=l.feeAmount/l.amount;for(let r=0;r<d.length;r++){const a=d[r],n=roundAmount(a.amount),o=roundAmount(n*t);o>0&&await(0,gateway_1.collectGatewayFee)({currency:a.currency,walletType:a.walletType,feeAmount:o,merchantId:l.merchant.id,paymentId:l.id,transaction:e});await(0,gateway_1.updateMerchantBalanceForPayment)({merchantId:l.merchantId,currency:a.currency,walletType:a.walletType,amount:n,feeAmount:o,transaction:e})}}const c=new Date;await l.update({status:"COMPLETED",customerId:n.id,transactionId:(null===(t=a[0])||void 0===t?void 0:t.id)||null,completedAt:c,ipAddress:(null==s?void 0:s["x-forwarded-for"])||(null==s?void 0:s["x-real-ip"]),userAgent:null==s?void 0:s["user-agent"],customerEmail:n.email,customerName:`${n.firstName||""} ${n.lastName||""}`.trim()||null,allocations:d,metadata:{...l.metadata,isTestMode:m,transactionIds:m?"[]":JSON.stringify(a.map(e=>e.id))}},{transaction:e});return{transactionRecords:a,completedAt:c}});null==i||i.step("Send payment completion webhook");if(l.webhookUrl)try{await(0,gateway_1.sendWebhook)(l.merchant.id,l.id,null,"payment.completed",l.webhookUrl,{id:`evt_${l.paymentIntentId}`,type:"payment.completed",createdAt:(new Date).toISOString(),data:{id:l.paymentIntentId,merchantOrderId:l.merchantOrderId,amount:l.amount,currency:l.currency,feeAmount:l.feeAmount,netAmount:l.netAmount,status:"COMPLETED",customerEmail:n.email,metadata:l.metadata,completedAt:e.completedAt.toISOString(),allocations:d}},l.merchant.webhookSecret)}catch(e){console_1.logger.error("GATEWAY_CHECKOUT","Failed to send payment.completed webhook",e)}null==i||i.step("Build success redirect URL");const t=new URL(l.returnUrl);t.searchParams.set("payment_id",l.paymentIntentId);t.searchParams.set("status","success");null==i||i.success("Payment confirmed successfully");return{success:!0,paymentId:l.paymentIntentId,status:"COMPLETED",redirectUrl:t.toString()}}catch(e){console_1.logger.error("GATEWAY_CHECKOUT","Payment confirmation failed",e);e.errors&&console_1.logger.debug("GATEWAY_CHECKOUT",`Validation errors: ${JSON.stringify(e.errors,null,2)}`);"PROCESSING"===l.status&&await l.update({status:"PENDING"});if("SequelizeValidationError"===e.name||"SequelizeUniqueConstraintError"===e.name){const t=(null===(r=e.errors)||void 0===r?void 0:r.map(e=>e.message).join(", "))||e.message;throw(0,error_1.createError)({statusCode:400,message:t})}if(l.webhookUrl&&402!==e.statusCode)try{await(0,gateway_1.sendWebhook)(l.merchant.id,l.id,null,"payment.failed",l.webhookUrl,{id:`evt_${l.paymentIntentId}`,type:"payment.failed",createdAt:(new Date).toISOString(),data:{id:l.paymentIntentId,merchantOrderId:l.merchantOrderId,amount:l.amount,currency:l.currency,status:"FAILED",error:e.message}},l.merchant.webhookSecret)}catch(e){console_1.logger.error("GATEWAY_CHECKOUT","Failed to send payment.failed webhook",e)}throw e}};