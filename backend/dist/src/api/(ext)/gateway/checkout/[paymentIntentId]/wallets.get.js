"use strict";async function getPriceInUSD(e,t){try{return"FIAT"===t?await(0,utils_1.getFiatPriceInUSD)(e):"SPOT"===t?await(0,utils_1.getSpotPriceInUSD)(e):"ECO"===t?await(0,utils_1.getEcoPriceInUSD)(e):0}catch(e){return 0}}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),gateway_1=require("@b/utils/gateway"),utils_1=require("@b/api/finance/currency/utils");exports.metadata={summary:"Get available wallets for checkout",description:"Retrieves all user wallets that can be used for payment based on gateway settings. Returns wallet balances and exchange rates.",operationId:"getCheckoutWallets",tags:["Gateway","Checkout"],parameters:[{name:"paymentIntentId",in:"path",required:!0,description:"Payment intent ID",schema:{type:"string"}}],responses:{200:{description:"Available wallets with balances and exchange rates"},401:{description:"Authentication required"},404:{description:"Payment not found"}},requiresAuth:!0,logModule:"GATEWAY",logTitle:"Get Checkout Wallets"};exports.default=async e=>{const{params:t,user:r,ctx:a}=e,{paymentIntentId:n}=t;if(!(null==r?void 0:r.id))throw(0,error_1.createError)({statusCode:401,message:"Authentication required"});const s=await db_1.models.gatewayPayment.findOne({where:{paymentIntentId:n},include:[{model:db_1.models.gatewayMerchant,as:"merchant",attributes:["id","name","status"]}]});if(!s)throw(0,error_1.createError)({statusCode:404,message:"Payment not found"});if("PENDING"!==s.status&&"PROCESSING"!==s.status)throw(0,error_1.createError)({statusCode:400,message:`Payment is ${s.status.toLowerCase()}`});if(new Date(s.expiresAt)<new Date)throw(0,error_1.createError)({statusCode:400,message:"Payment session has expired"});const c=(await(0,gateway_1.getGatewaySettings)()).gatewayAllowedWalletTypes||{},o=await getPriceInUSD(s.currency,s.walletType);if(!o||o<=0)throw(0,error_1.createError)({statusCode:400,message:`Could not determine price for payment currency ${s.currency}`});const u=[];for(const[e,t]of Object.entries(c))if(t&&t.enabled&&t.currencies)for(const r of t.currencies)u.push({type:e,currency:r});0===u.length&&u.push({type:s.walletType,currency:s.currency});const i=await db_1.models.wallet.findAll({where:{userId:r.id},attributes:["id","type","currency","balance"]}),l=[];for(const e of i){if(!u.some(t=>t.type===e.type&&t.currency===e.currency))continue;const t=parseFloat(e.balance);if(t<=0)continue;const r=await getPriceInUSD(e.currency,e.type);if(!r||r<=0)continue;const a=r/o,n=t*a;l.push({id:e.id,type:e.type,currency:e.currency,balance:t,priceInUSD:r,exchangeRate:a,equivalentAmount:n,canCoverFull:n>=s.amount})}l.sort((e,t)=>{const r=e.type===s.walletType&&e.currency===s.currency,a=t.type===s.walletType&&t.currency===s.currency;return r&&!a?-1:!r&&a?1:e.canCoverFull&&!t.canCoverFull?-1:!e.canCoverFull&&t.canCoverFull?1:t.equivalentAmount-e.equivalentAmount});const y=l.reduce((e,t)=>e+t.equivalentAmount,0);null==a||a.success("Request completed successfully");return{payment:{id:s.paymentIntentId,amount:s.amount,currency:s.currency,walletType:s.walletType,priceInUSD:o},wallets:l,canPayFull:y>=s.amount,totalEquivalent:y,shortfall:Math.max(0,s.amount-y)}};