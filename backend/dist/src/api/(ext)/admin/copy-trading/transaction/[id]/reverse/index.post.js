"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),sequelize_1=require("sequelize"),error_1=require("@b/utils/error"),utils_1=require("@b/api/(ext)/copy-trading/utils"),wallet_1=require("@b/services/wallet"),errors_1=require("@b/utils/schema/errors");exports.metadata={summary:"Reverse copy trading transaction",description:"Creates a reversing transaction to undo a previous copy trading transaction. Determines the appropriate reversal type based on the original transaction type, adjusts wallet balances, updates follower statistics, and creates an audit log. Validates that the transaction has not already been reversed and ensures wallet balance remains positive after reversal.",operationId:"adminReverseCopyTradingTransaction",tags:["Admin","Copy Trading","Transactions"],requiresAuth:!0,permission:"access.copy_trading",middleware:["copyTradingAdmin"],logModule:"ADMIN_COPY",logTitle:"Reverse copy trading transaction",parameters:[{name:"id",in:"path",required:!0,schema:{type:"string"},description:"Transaction ID to reverse"}],requestBody:{required:!0,content:{"application/json":{schema:{type:"object",properties:{reason:{type:"string",description:"Reason for reversal"}},required:["reason"]}}}},responses:{200:{description:"Transaction reversed successfully",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string"},originalTransaction:{type:"object",description:"The original transaction that was reversed"},reversalTransaction:{type:"object",description:"The new reversing transaction"}}}}}},400:errors_1.badRequestResponse,401:errors_1.unauthorizedResponse,403:errors_1.forbiddenResponse,404:(0,errors_1.notFoundResponse)("Transaction"),500:errors_1.serverErrorResponse}};exports.default=async e=>{const{user:r,params:a,body:t,ctx:s}=e,{id:n}=a,{reason:o}=t||{};if(!(null==r?void 0:r.id)){null==s||s.fail("Unauthorized");throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"})}null==s||s.step("Validating reversal reason");if(!o){null==s||s.fail("Reason is required");throw(0,error_1.createError)({statusCode:400,message:"Reason is required"})}null==s||s.step("Fetching original transaction");const i=await db_1.models.copyTradingTransaction.findByPk(n,{include:[{model:db_1.models.user,as:"user",attributes:["id","firstName","lastName"]}]});if(!i){null==s||s.fail("Transaction not found");throw(0,error_1.createError)({statusCode:404,message:"Transaction not found"})}null==s||s.step("Checking for existing reversal");if(await db_1.models.copyTradingTransaction.findOne({where:{description:{[sequelize_1.Op.like]:`%Reversal of transaction ${n}%`}}})){null==s||s.fail("Transaction has already been reversed");throw(0,error_1.createError)({statusCode:400,message:"Transaction has already been reversed"})}null==s||s.step("Determining reversal type");let l,d,c;switch(i.type){case"ALLOCATION":l="DEALLOCATION";d=i.amount;break;case"DEALLOCATION":l="ALLOCATION";d=-i.amount;break;case"PROFIT":l="LOSS";d=-i.amount;break;case"LOSS":l="PROFIT";d=i.amount;break;case"PROFIT_SHARE":case"PLATFORM_FEE":l="REFUND";d=i.amount;break;case"REFUND":null==s||s.fail("Cannot reverse a refund transaction");throw(0,error_1.createError)({statusCode:400,message:"Cannot reverse a refund transaction"});default:null==s||s.fail(`Cannot reverse transaction type: ${i.type}`);throw(0,error_1.createError)({statusCode:400,message:`Cannot reverse transaction type: ${i.type}`})}null==s||s.step("Processing reversal transaction");await db_1.sequelize.transaction(async e=>{if(0!==d){null==s||s.step("Adjusting wallet balance via wallet service");const a=i.currency||"USDT",t=await wallet_1.walletCreationService.getOrCreateWallet(i.userId,"SPOT",a),c=`ct_reversal_${n}`;if(d>0)await wallet_1.walletService.credit({idempotencyKey:c,userId:i.userId,walletId:t.id,walletType:"SPOT",currency:a,amount:d,operationType:"COPY_TRADING_REVERSAL",referenceId:n,description:`Reversal of transaction ${n}: ${o}`,metadata:{originalTransactionId:n,originalType:i.type,reversalType:l,reversedBy:r.id},transaction:e});else{const u=Math.abs(d);if(t.balance<u){null==s||s.fail("Reversal would result in negative wallet balance");throw(0,error_1.createError)({statusCode:400,message:"Reversal would result in negative wallet balance"})}await wallet_1.walletService.debit({idempotencyKey:c,userId:i.userId,walletId:t.id,walletType:"SPOT",currency:a,amount:u,operationType:"COPY_TRADING_REVERSAL",referenceId:n,description:`Reversal of transaction ${n}: ${o}`,metadata:{originalTransactionId:n,originalType:i.type,reversalType:l,reversedBy:r.id},transaction:e})}}null==s||s.step("Creating reversal transaction");c=await(0,utils_1.createCopyTradingTransaction)({userId:i.userId,leaderId:i.leaderId,followerId:i.followerId,tradeId:i.tradeId,type:l,amount:i.amount,currency:i.currency,fee:0,balanceBefore:i.balanceAfter,balanceAfter:i.balanceAfter+d,description:`Reversal of transaction ${n}: ${o}`,metadata:{originalTransactionId:n,reversedBy:r.id,reason:o}});if(i.followerId){null==s||s.step("Updating follower statistics");const r=await db_1.models.copyTradingFollower.findByPk(i.followerId,{transaction:e});if(r){let a=r.allocatedAmount,t=r.totalProfit;"ALLOCATION"===l?a+=i.amount:"DEALLOCATION"===l?a-=i.amount:"PROFIT"===l?t+=i.amount:"LOSS"===l&&(t-=i.amount);await r.update({allocatedAmount:Math.max(0,a),totalProfit:t},{transaction:e})}}null==s||s.step("Creating audit log");await(0,utils_1.createAuditLog)({entityType:"TRANSACTION",entityId:n,action:"REVERSE",oldValue:i.toJSON(),newValue:{reversalTransactionId:c.id,reason:o},adminId:r.id,reason:o})});null==s||s.success("Transaction reversed successfully");return{message:"Transaction reversed successfully",originalTransaction:i.toJSON(),reversalTransaction:c}};