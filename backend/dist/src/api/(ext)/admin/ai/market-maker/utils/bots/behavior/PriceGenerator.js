"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.PriceGenerator=void 0;class PriceGenerator{constructor(){this.psychologicalEndings={"0.00":.25,"0.50":.15,.25:.08,.75:.08,.99:.1,.01:.08,.95:.06,.05:.06,random:.14};this.keyLevels=new Map;this.priceHistory=[]}generateBuyPrice(e,t={}){const{aggressiveness:r=.5,preferPsychological:s=!0,nearSupport:o}=t;let i=e*(1-(.001+.005*(1-r)));o&&Math.abs(i-o)/i<.02&&(i=o*(1+.002*Math.random()));s&&(i=this.applyPsychologicalPricing(i));i=this.addImprecision(i);return i}generateSellPrice(e,t={}){const{aggressiveness:r=.5,preferPsychological:s=!0,nearResistance:o}=t;let i=e*(1+(.001+.005*(1-r)));o&&Math.abs(i-o)/i<.02&&(i=o*(1-.002*Math.random()));s&&(i=this.applyPsychologicalPricing(i));i=this.addImprecision(i);return i}generateStopLossPrice(e,t,r=.02){let s;s="BUY"===t?e*(1-r):e*(1+r);return this.roundToPsychologicalLevel(s)}generateTakeProfitPrice(e,t,r=.04){let s;s="BUY"===t?e*(1+r):e*(1-r);return this.roundToPsychologicalLevel(s)}isPsychologicalLevel(e){const t=e%1,r=[0,.25,.5,.75,.99,.01,.05,.95];for(const e of r)if(Math.abs(t-e)<.01)return!0;const s=Math.round(e);return Math.abs(e-s)/e<.005}findNearestPsychLevel(e,t){const r=Math.floor(e),s=e-r,o=[0,.05,.1,.25,.5,.75,.9,.95,1];let i=o[0],n=Math.abs(s-i);for(const e of o){const r=Math.abs(s-e);if("NEAREST"===t&&r<n){i=e;n=r}else if("UP"===t&&e>s&&r<n){i=e;n=r}else if("DOWN"===t&&e<s&&r<n){i=e;n=r}}return r+i}addKeyLevel(e,t){this.keyLevels.has(e)||this.keyLevels.set(e,[]);const r=this.keyLevels.get(e);if(!r.includes(t)){r.push(t);r.sort((e,t)=>e-t)}r.length>20&&r.shift()}getNearestKeyLevel(e,t,r){const s=this.keyLevels.get(e)||[];if("SUPPORT"===r){const e=s.filter(e=>e<t);return e.length>0?Math.max(...e):null}{const e=s.filter(e=>e>t);return e.length>0?Math.min(...e):null}}recordPrice(e){this.priceHistory.push({price:e,timestamp:Date.now()});this.priceHistory.length>1e3&&this.priceHistory.shift();this.detectKeyLevels()}applyPsychologicalPricing(e){const t=Math.random();let r=0;for(const[s,o]of Object.entries(this.psychologicalEndings)){r+=o;if(t<r)return"random"===s?e:this.applyEnding(e,s)}return e}applyEnding(e,t){const r=Math.floor(e),s=parseFloat(t),o=e-r;return o<s?r+s:"0.00"===t?o<.5?r:r+1:r+s}roundToPsychologicalLevel(e){const t=[0,.25,.5,.75,1],r=Math.floor(e),s=e-r;let o=t[0],i=Math.abs(s-o);for(const e of t){const t=Math.abs(s-e);if(t<i){o=e;i=t}}return r+o}addImprecision(e){return e*(1+.001*(Math.random()-.5))}detectKeyLevels(){if(this.priceHistory.length<100)return;const e=this.priceHistory.slice(-100).map(e=>e.price),t=(Math.max(...e)-Math.min(...e))/20;if(t<=0)return;const r=new Map;for(const s of e){const e=Math.floor(s/t)*t;r.set(e,(r.get(e)||0)+1)}const s=e.length/10;for(const[e,o]of r.entries())o>=s&&this.addKeyLevel("default",e+t/2)}getStats(){const e=this.priceHistory.slice(-100);return{priceCount:this.priceHistory.length,keyLevelCount:Array.from(this.keyLevels.values()).flat().length,recentRange:e.length>0?{high:Math.max(...e.map(e=>e.price)),low:Math.min(...e.map(e=>e.price))}:null}}}exports.PriceGenerator=PriceGenerator;exports.default=PriceGenerator;