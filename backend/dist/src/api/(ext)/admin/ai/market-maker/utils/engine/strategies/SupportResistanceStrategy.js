"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.SupportResistanceStrategy=void 0;class SupportResistanceStrategy{constructor(){this.name="support_resistance";this.supportLevels=new Map;this.resistanceLevels=new Map}calculate(e,t,r){const s=Number(e)/1e18,n=Number(t)/1e18,i=this.calculateLevels(n,r),a=this.findNearestBelow(s,i.support),o=this.findNearestAbove(s,i.resistance),u=o?(o-s)/s*100:100;if((a?(s-a)/s*100:100)<.5)return{shouldTrade:!0,direction:"BUY",priceAdjustment:.05,sizeMultiplier:1.5,confidence:.9,reason:`Defending support at ${null==a?void 0:a.toFixed(8)}`};if(u<.5)return{shouldTrade:!0,direction:"SELL",priceAdjustment:.05,sizeMultiplier:1.5,confidence:.9,reason:`Defending resistance at ${null==o?void 0:o.toFixed(8)}`};const c=(n-s)/s*100;if(Math.abs(c)<.5)return{shouldTrade:Math.random()>.7,direction:Math.random()>.5?"BUY":"SELL",priceAdjustment:.02,sizeMultiplier:.5,confidence:.3,reason:"Maintaining around target"};return{shouldTrade:!0,direction:c>0?"BUY":"SELL",priceAdjustment:Math.min(.1,.1*Math.abs(c)),sizeMultiplier:1,confidence:.6,reason:`Moving toward target (${c.toFixed(2)}% away)`}}calculateLevels(e,t){const r=[],s=[],n=this.getLevelSpacing(t.aggressionLevel);for(let t=1;t<=5;t++){r.push(e*(1-n*t));s.push(e*(1+n*t))}r.push(t.priceRangeLow);s.push(t.priceRangeHigh);return{support:r.sort((e,t)=>t-e),resistance:s.sort((e,t)=>e-t)}}findNearestBelow(e,t){for(const r of t)if(r<e)return r;return null}findNearestAbove(e,t){for(const r of t)if(r>e)return r;return null}getLevelSpacing(e){switch(e){case"AGGRESSIVE":return.01;case"MODERATE":return.02;default:return.03}}}exports.SupportResistanceStrategy=SupportResistanceStrategy;exports.default=SupportResistanceStrategy;