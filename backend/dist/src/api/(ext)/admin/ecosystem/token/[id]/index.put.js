"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const query_1=require("@b/utils/query"),errors_1=require("@b/utils/schema/errors"),utils_1=require("../utils"),db_1=require("@b/db"),error_1=require("@b/utils/error");exports.metadata={summary:"Updates an ecosystem token",description:"Updates an existing ecosystem token's metadata including status, limits, fees, and icon. Validates that the associated blockchain is active before allowing status changes. Automatically updates the token icon cache when a new icon is provided.",operationId:"updateEcosystemToken",tags:["Admin","Ecosystem","Token"],logModule:"ADMIN_ECO",logTitle:"Update token",parameters:[{index:0,name:"id",in:"path",description:"ID of the token to update",required:!0,schema:{type:"string"}}],requestBody:{description:"Updated ecosystem token data",content:{"application/json":{schema:utils_1.ecosystemTokenUpdateSchema}}},responses:{200:{description:"Ecosystem token updated successfully",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Success message"}}}}}},400:errors_1.badRequestResponse,401:query_1.unauthorizedResponse,404:(0,errors_1.notFoundResponse)("Ecosystem Token"),500:query_1.serverErrorResponse},requiresAuth:!0,permission:"edit.ecosystem.token"};exports.default=async e=>{const{body:t,params:s,ctx:o}=e,{id:n}=s,{status:r,limits:a,fee:i,icon:c}=t;null==o||o.step("Validating token exists");const d=await db_1.models.ecosystemToken.findByPk(n);if(!d)throw(0,error_1.createError)({statusCode:404,message:`Token with ID ${n} not found`});null==o||o.step("Checking blockchain status");const u=await db_1.models.ecosystemBlockchain.findOne({where:{chain:d.chain}});if(u&&!u.status)throw"0.0.1"===u.version?(0,error_1.createError)({statusCode:400,message:`Please install the latest version of the blockchain ${d.chain} to enable this token`}):(0,error_1.createError)({statusCode:400,message:`${d.chain} Blockchain is disabled`});try{null==o||o.step("Updating token record");const e=await(0,query_1.updateRecord)("ecosystemToken",n,{status:r,limits:JSON.stringify(a),fee:JSON.stringify(i),icon:c},!0);if(e&&c){const e=await db_1.models.ecosystemToken.findByPk(n);if(e&&e.currency)try{null==o||o.step("Updating token icon in cache");await(0,utils_1.updateIconInCache)(e.currency,c)}catch(t){null==o||o.warn(`Failed to update icon in cache: ${t.message}`);console.error(`Failed to update icon in cache for ${e.currency}:`,t)}}null==o||o.success("Token updated successfully");return e}catch(e){null==o||o.fail(e.message);console.error("Error updating ecosystem token:",e);throw e}};