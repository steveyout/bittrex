"use strict";function safeToISOString(e){if(!e)return null;try{const t=new Date(e);return isNaN(t.getTime())?null:t.toISOString()}catch(e){return null}}function computeIcoOfferTimeline(e,t){var i;const a=[],s=safeToISOString(e.createdAt);s&&a.push({id:"created",type:"created",timestamp:s,adminName:"System",details:"Offering created"});const n=safeToISOString(e.startDate);n&&"ACTIVE"===e.status&&a.push({id:"launched",type:"launched",timestamp:n,adminName:"System",details:"Offering launched"});const r=safeToISOString(e.endDate);r&&a.push({id:"completed",type:"completed",timestamp:r,adminName:"System",details:"Offering completed"});const o=safeToISOString(e.submittedAt);o&&a.push({id:"submitted",type:"submission",timestamp:o,adminName:(null===(i=e.user)||void 0===i?void 0:i.name)||"Creator",details:"Offering submitted for review"});const d=safeToISOString(e.approvedAt);d&&a.push({id:"approved",type:"approval",timestamp:d,adminName:"Admin",details:"Offering approved"});const l=safeToISOString(e.rejectedAt);l&&a.push({id:"rejected",type:"rejection",timestamp:l,adminName:"Admin",details:"Offering rejected"});e.updates&&Array.isArray(e.updates)&&e.updates.forEach(e=>{var t;const i=safeToISOString(e.createdAt);i&&a.push({id:e.id,type:"note",timestamp:i,adminName:(null===(t=e.user)||void 0===t?void 0:t.name)||"Admin",details:`${e.title}: ${e.content}`})});e.roadmapItems&&Array.isArray(e.roadmapItems)&&e.roadmapItems.forEach(e=>{const t=safeToISOString(e.date);t&&a.push({id:`roadmap-${e.id}`,type:"milestone",timestamp:t,adminName:"System",details:`${e.title} - ${e.description}`,important:e.completed})});if(e.phases&&Array.isArray(e.phases)){const t=e.startDate?new Date(e.startDate):null;let i=t&&!isNaN(t.getTime())?t:null;e.phases.forEach(e=>{let t=safeToISOString(e.startDate);!t&&i&&(t=i.toISOString());t&&a.push({id:`phase-${e.id}`,type:"phase",timestamp:t,adminName:"System",details:`Phase ${e.name} started. Token Price: ${e.tokenPrice}`});i&&e.duration&&(i=new Date(i.getTime()+864e5*e.duration))})}e.adminActivities&&Array.isArray(e.adminActivities)&&e.adminActivities.forEach(e=>{const t=safeToISOString(e.createdAt);t&&a.push({id:`activity-${e.id}`,type:e.type||"activity",timestamp:t,adminName:e.adminName||"Admin",details:e.details||""})});a.forEach(t=>{t.offeringId=e.id;t.offeringName=e.name});a.sort((e,t)=>new Date(e.timestamp).getTime()-new Date(t.timestamp).getTime());null==t||t.success("Get ICO Offer retrieved successfully");return a}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),sequelize_1=require("sequelize"),cache_1=require("@b/utils/cache");exports.metadata={summary:"Get ICO Offering (Admin)",description:"Retrieves a single ICO offering by its ID for admin review and management, including calculated metrics (with rejected investments), platform averages, and timeline events.",operationId:"getIcoOfferingAdmin",tags:["ICO","Admin","Offerings"],requiresAuth:!0,logModule:"ADMIN_ICO",logTitle:"Get ICO Offer",parameters:[{name:"id",in:"path",required:!0,schema:{type:"string",description:"The ID of the ICO offering."}}],responses:{200:{description:"ICO offering retrieved successfully with calculated metrics, platform averages, and timeline events.",content:{"application/json":{schema:{type:"object",description:"An object containing the ICO offering record, its computed metrics (including rejected funds), platform averages, and timeline events."}}}},401:{description:"Unauthorized â€“ Admin privileges required."},404:{description:"ICO offering not found."},500:{description:"Internal Server Error"}},permission:"view.ico.offer"};exports.default=async e=>{const{user:t,params:i,ctx:a}=e;null==a||a.step("Validate user authentication");if(!(null==t?void 0:t.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized: Admin privileges required."});const s=i.id;if(!s||"string"!=typeof s)throw(0,error_1.createError)({statusCode:400,message:"Invalid offering ID."});const n=await db_1.models.icoTokenOffering.findOne({where:{id:s},include:[{model:db_1.models.icoTokenDetail,as:"tokenDetail",include:[{model:db_1.models.icoTokenType,as:"tokenTypeData"}]},{model:db_1.models.icoLaunchPlan,as:"plan"},{model:db_1.models.icoTokenOfferingUpdate,as:"updates",include:[{model:db_1.models.user,as:"user"}]},{model:db_1.models.icoTokenOfferingPhase,as:"phases"},{model:db_1.models.icoRoadmapItem,as:"roadmapItems"},{model:db_1.models.icoAdminActivity,as:"adminActivities"},{model:db_1.models.user,as:"user"}]});if(!n)throw(0,error_1.createError)({statusCode:404,message:"ICO offering not found."});const r=cache_1.CacheManager.getInstance(),o=await r.getSetting("icoMinInvestmentAmount"),d=Number(o)||100,l=864e5,m=n.startDate?new Date(n.startDate):null,u=n.endDate?new Date(n.endDate):null;if(!m)throw(0,error_1.createError)({statusCode:500,message:"Offering start date is missing."});const c=new Date,f="SUCCESS"===n.status&&u?Math.floor((u.getTime()-m.getTime())/l):Math.floor((c.getTime()-m.getTime())/l),[p,g]=await Promise.all([db_1.models.icoTransaction.findOne({attributes:[[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("CASE WHEN status NOT IN ('REJECTED') THEN price * amount ELSE 0 END")),"computedRaised"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("CASE WHEN status = 'REJECTED' THEN price * amount ELSE 0 END")),"rejectedFunds"]],where:{offeringId:s},raw:!0}),db_1.models.icoTransaction.findAll({attributes:["userId",[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("price * amount")),"totalCost"],[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.literal)("id")),"transactionCount"]],where:{offeringId:s,status:{[sequelize_1.Op.not]:["REJECTED"]}},group:["userId"],raw:!0})]),I=parseFloat(null==p?void 0:p.computedRaised)||0,v=parseFloat(null==p?void 0:p.rejectedFunds)||0,O=I/(f||1),T=I/(n.participants||1),_=f,h=g.reduce((e,t)=>{const i=Number(t.totalCost)||0;return i>e?i:e},0),S=g.reduce((e,t)=>e+Number(t.transactionCount),0),E={avgInvestment:T,fundingRate:O,largestInvestment:h,smallestInvestment:d,transactionsPerInvestor:g.length>0?S/g.length:0,completionTime:_,rejectedInvestment:v,currentRaised:I},[C,A,b,D,q]=await Promise.all([db_1.models.icoTransaction.findOne({attributes:[[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("price * amount")),"totalRaisedAll"]],include:[{model:db_1.models.icoTokenOffering,as:"offering",attributes:[],where:{status:{[sequelize_1.Op.in]:["ACTIVE","SUCCESS"]}}}],raw:!0}),db_1.models.icoTokenOffering.findOne({attributes:[[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("participants")),"totalParticipants"],[(0,sequelize_1.fn)("AVG",(0,sequelize_1.literal)("TIMESTAMPDIFF(DAY, startDate, endDate)")),"avgDuration"]],where:{status:{[sequelize_1.Op.in]:["ACTIVE","SUCCESS"]}},raw:!0}),db_1.models.icoTokenOffering.findOne({attributes:[[(0,sequelize_1.fn)("MAX",(0,sequelize_1.literal)("(SELECT SUM(amount * price) FROM ico_transaction \n                       WHERE ico_transaction.offeringId = icoTokenOffering.id \n                       AND status IN ('PENDING', 'RELEASED'))")),"maxInvestment"]],raw:!0}),db_1.models.icoTransaction.findOne({attributes:[[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("price * amount")),"totalCost"],[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.literal)("id")),"transactionCount"],[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.fn)("DISTINCT",(0,sequelize_1.col)("userId"))),"investorCount"]],where:{status:{[sequelize_1.Op.not]:["REJECTED"]}},raw:!0}),db_1.models.icoTransaction.findOne({attributes:[[(0,sequelize_1.fn)("COALESCE",(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("price * amount")),0),"rejectedFunds"]],where:{status:"REJECTED"},raw:!0})]),y=parseFloat(null==C?void 0:C.totalRaisedAll)||0,N=parseFloat(null==A?void 0:A.totalParticipants)||0,w=parseFloat(null==A?void 0:A.avgDuration)||0,z=N>0?y/N:0,M=w>0?y/w:0,R=b&&parseFloat(b.maxInvestment)||0,U=d,j=parseFloat(null==D?void 0:D.transactionCount)||0,F=parseFloat(null==D?void 0:D.investorCount)||0;return{offering:n,metrics:E,platformMetrics:{avgInvestment:z,fundingRate:M,largestInvestment:R,smallestInvestment:U,transactionsPerInvestor:F>0?j/F:0,completionTime:w,rejectedInvestment:parseFloat(null==q?void 0:q.rejectedFunds)||0},timeline:computeIcoOfferTimeline(n,a)}};