"use strict";async function getDailyChartData(e,t,a){const r=await db_1.models.icoTransaction.findAll({attributes:[[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-%d')"),"period"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("amount * price")),"raised"]],where:{offeringId:e,createdAt:{[sequelize_1.Op.between]:[t,a]},status:{[sequelize_1.Op.not]:["REJECTED"]}},group:[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-%d')")],order:[(0,sequelize_1.literal)("period")],raw:!0}),i=await db_1.models.icoTransaction.findAll({attributes:[[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-%d')"),"period"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("amount * price")),"raised"]],where:{offeringId:e,createdAt:{[sequelize_1.Op.between]:[t,a]},status:"REJECTED"},group:[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-%d')")],order:[(0,sequelize_1.literal)("period")],raw:!0}),n=r.reduce((e,t)=>{e[t.period]=parseFloat(t.raised);return e},{}),o=i.reduce((e,t)=>{e[t.period]=parseFloat(t.raised);return e},{}),l=[];let s=0,u=0,d=0;for(let e=new Date(t);e<=a;e.setDate(e.getDate()+1)){const t=`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")}`,a=n[t]||0,r=o[t]||0,i=a+r;s+=a;u+=r;d+=i;l.push({date:t,validAmount:a,validCumulative:s,rejectedAmount:r,rejectedCumulative:u,totalAmount:i,totalCumulative:d})}return l}async function getMonthlyChartData(e,t,a){const r=await db_1.models.icoTransaction.findAll({attributes:[[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-01')"),"period"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("amount * price")),"raised"]],where:{offeringId:e,createdAt:{[sequelize_1.Op.gte]:t},status:{[sequelize_1.Op.not]:["REJECTED"]}},group:[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-01')")],order:[(0,sequelize_1.literal)("period")],raw:!0}),i=await db_1.models.icoTransaction.findAll({attributes:[[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-01')"),"period"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("amount * price")),"raised"]],where:{offeringId:e,createdAt:{[sequelize_1.Op.gte]:t},status:"REJECTED"},group:[(0,sequelize_1.literal)("DATE_FORMAT(icoTransaction.createdAt, '%Y-%m-01')")],order:[(0,sequelize_1.literal)("period")],raw:!0}),n=r.reduce((e,t)=>{e[t.period]=parseFloat(t.raised);return e},{}),o=i.reduce((e,t)=>{e[t.period]=parseFloat(t.raised);return e},{}),l=[];let s=0,u=0,d=0;for(let e=new Date(t);e<=a;e.setMonth(e.getMonth()+1)){const t=`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-01`,a=n[t]||0,r=o[t]||0,i=a+r;s+=a;u+=r;d+=i;l.push({date:t,validAmount:a,validCumulative:s,rejectedAmount:r,rejectedCumulative:u,totalAmount:i,totalCumulative:d})}for(;l.length<12;){const e=l[0],t=new Date(e.date);t.setMonth(t.getMonth()-1);const a=`${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,"0")}-01`;l.unshift({date:a,validAmount:0,validCumulative:e.validCumulative,rejectedAmount:0,rejectedCumulative:e.rejectedCumulative,totalAmount:0,totalCumulative:e.totalCumulative})}return l}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),sequelize_1=require("sequelize");exports.metadata={summary:"Get Funding Chart Data for an Offering",description:"Retrieves funding chart data (daily aggregated amounts with cumulative totals) for a specific ICO offering based on the specified time range. The data now includes valid funds (from all non-rejected transactions) and rejected funds.",operationId:"getAdminFundingChartData",tags:["ICO","Admin","FundingChart"],requiresAuth:!0,logModule:"ADMIN_ICO",logTitle:"Get ICO Offer Funding",parameters:[{index:0,name:"id",in:"path",required:!0,schema:{type:"string"},description:"The ID of the ICO offering."},{index:1,name:"range",in:"query",required:!0,schema:{type:"string"},description:"Time range for chart data: '7d' for current week, '30d' for current month, '90d' for three full months, or 'all' for all time (monthly, ensuring at least 12 months)."}],responses:{200:{description:"Funding chart data retrieved successfully.",content:{"application/json":{schema:{type:"array",items:{type:"object",properties:{date:{type:"string"},validAmount:{type:"number"},validCumulative:{type:"number"},rejectedAmount:{type:"number"},rejectedCumulative:{type:"number"},totalAmount:{type:"number"},totalCumulative:{type:"number"}}},description:"Array of funding data points including breakdown of valid and rejected funds."}}}},401:{description:"Unauthorized"},404:{description:"ICO offering not found"},500:{description:"Internal Server Error"}},permission:"view.ico.offer"};exports.default=async e=>{const{user:t,params:a,query:r,ctx:i}=e;null==i||i.step("Validate user authentication");if(!(null==t?void 0:t.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});const n=a.id;if(!await db_1.models.icoTokenOffering.findOne({where:{id:n}}))throw(0,error_1.createError)({statusCode:404,message:"ICO offering not found."});const o=new Date,l=r.range||"30d";let s=[];if("7d"===l){const e=o.getDay(),t=0===e?-6:1-e,a=new Date(o);a.setDate(o.getDate()+t);const r=new Date(a);r.setDate(a.getDate()+6);s=await getDailyChartData(n,a,r)}else if("30d"===l){const e=new Date(o.getFullYear(),o.getMonth(),1),t=new Date(o.getFullYear(),o.getMonth()+1,0);s=await getDailyChartData(n,e,t)}else if("90d"===l){const e=new Date(o.getFullYear(),o.getMonth()-2,1),t=new Date(o.getFullYear(),o.getMonth()+1,0);s=await getDailyChartData(n,e,t)}else{const e=await db_1.models.icoTransaction.findOne({attributes:[[(0,sequelize_1.fn)("MIN",(0,sequelize_1.literal)("icoTransaction.createdAt")),"minDate"]],where:{offeringId:n},raw:!0});let t;if(e&&e.minDate)t=new Date(e.minDate);else{t=new Date;t.setFullYear(t.getFullYear()-1)}const a=new Date(o.getFullYear(),o.getMonth()-11,1);t>a&&(t=a);s=await getMonthlyChartData(n,t,o)}null==i||i.success("Get ICO Offer Funding retrieved successfully");return s};