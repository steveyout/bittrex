"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),gateway_1=require("@b/utils/gateway"),console_1=require("@b/utils/console"),errors_1=require("@b/utils/schema/errors");exports.metadata={summary:"Create refund for gateway payment",description:"Admin creates a full or partial refund for a completed gateway payment. Processes fund transfer from merchant gateway balance back to customer wallet(s), returns proportional fees, updates payment status, and sends webhook notification. Supports multi-wallet refunds distributed proportionally to original payment allocations.",operationId:"createGatewayPaymentRefund",tags:["Admin","Gateway","Refund"],parameters:[{name:"id",in:"path",required:!0,description:"Payment UUID or payment intent ID (pi_xxx)",schema:{type:"string"}}],requestBody:{required:!1,content:{"application/json":{schema:{type:"object",properties:{amount:{type:"number",description:"Refund amount. If not provided, full remaining amount will be refunded."},reason:{type:"string",enum:["REQUESTED_BY_CUSTOMER","DUPLICATE","FRAUDULENT","OTHER"],description:"Reason for refund"},description:{type:"string",description:"Internal description for the refund"}}}}}},responses:{201:{description:"Refund created successfully",content:{"application/json":{schema:{type:"object",properties:{id:{type:"string",description:"Refund ID (ref_xxx)"},paymentId:{type:"string",description:"Payment intent ID"},amount:{type:"number",description:"Refund amount"},currency:{type:"string",description:"Currency code"},status:{type:"string",description:"Refund status"},reason:{type:"string",description:"Refund reason"},description:{type:"string",description:"Refund description"},createdAt:{type:"string",format:"date-time"}}}}}},400:errors_1.badRequestResponse,401:errors_1.unauthorizedResponse,404:(0,errors_1.notFoundResponse)("Payment"),500:errors_1.serverErrorResponse},requiresAuth:!0,permission:"manage.gateway.payment",logModule:"ADMIN_GATEWAY",logTitle:"Create payment refund"};exports.default=async e=>{var t,r;const{params:n,body:a,ctx:o}=e,{id:s}=n;null==o||o.step(`Looking up payment ${s}`);const d=s.startsWith("pi_")?{paymentIntentId:s}:{id:s},i=await db_1.models.gatewayPayment.findOne({where:d,include:[{model:db_1.models.gatewayMerchant,as:"merchant"}]});if(!i){null==o||o.fail("Payment not found");throw(0,error_1.createError)({statusCode:404,message:"Payment not found"})}const u=i.merchant;null==o||o.step("Validating payment status");if("COMPLETED"!==i.status&&"PARTIALLY_REFUNDED"!==i.status){null==o||o.fail(`Payment status ${i.status} cannot be refunded`);throw(0,error_1.createError)({statusCode:400,message:`Payment with status ${i.status} cannot be refunded`})}null==o||o.step("Calculating refundable amount");const c=(await db_1.models.gatewayRefund.findAll({where:{paymentId:i.id,status:"COMPLETED"}})).reduce((e,t)=>e+parseFloat(t.amount),0),l=i.amount-c,m=(null==a?void 0:a.amount)?parseFloat(a.amount):l;if(m<=0){null==o||o.fail("Refund amount must be greater than 0");throw(0,error_1.createError)({statusCode:400,message:"Refund amount must be greater than 0"})}if(m>l){null==o||o.fail("Refund amount exceeds remaining refundable amount");throw(0,error_1.createError)({statusCode:400,message:`Refund amount ${m.toFixed(2)} exceeds remaining refundable amount ${l.toFixed(2)}`})}null==o||o.step(`Processing refund of ${m} ${i.currency}`);const p=(0,gateway_1.generateRefundId)(),f=i.feeAmount/i.amount,y=m*f;let g;try{g=await db_1.sequelize.transaction(async e=>{const t=await db_1.models.gatewayRefund.create({paymentId:i.id,merchantId:u.id,refundId:p,amount:m,currency:i.currency,reason:(null==a?void 0:a.reason)||"REQUESTED_BY_CUSTOMER",description:(null==a?void 0:a.description)||null,status:"COMPLETED",metadata:null},{transaction:e});if(i.customerId&&!i.testMode){const r=i.allocations||[];if(0===r.length)throw(0,error_1.createError)({statusCode:400,message:"Payment has no allocation data for refund processing"});const n=await(0,gateway_1.processMultiWalletRefund)({userId:i.customerId,merchantUserId:u.userId,merchantId:u.id,paymentCurrency:i.currency,allocations:r,refundAmount:m,totalPaymentAmount:i.amount,feeAmount:y,refundId:p,paymentId:i.paymentIntentId,description:`Refund for payment ${i.paymentIntentId} (by admin)`,transaction:e});await t.update({transactionId:n.userTransaction.id},{transaction:e})}const r=c+m>=i.amount?"REFUNDED":"PARTIALLY_REFUNDED";await i.update({status:r},{transaction:e});return t})}catch(e){if("SequelizeValidationError"===e.name||"SequelizeUniqueConstraintError"===e.name){const t=[];e.errors&&Array.isArray(e.errors)&&e.errors.forEach(e=>{t.push(e.message)});const r=t.length>0?t.join("; "):e.message||"Validation failed";throw(0,error_1.createError)({statusCode:400,message:r})}if(null===(t=e.message)||void 0===t?void 0:t.includes("Insufficient"))throw(0,error_1.createError)({statusCode:400,message:e.message});if(null===(r=e.message)||void 0===r?void 0:r.includes("wallet not found"))throw(0,error_1.createError)({statusCode:400,message:e.message});if(e.statusCode)throw e;console_1.logger.error("ADMIN_GATEWAY_REFUND","Refund processing failed",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to process refund: ${e.message}`})}null==o||o.step("Sending webhook notification");if(i.webhookUrl)try{await(0,gateway_1.sendWebhook)(u.id,i.id,g.id,"refund.completed",i.webhookUrl,{id:`evt_${p}`,type:"refund.completed",createdAt:(new Date).toISOString(),data:{id:p,paymentId:i.paymentIntentId,merchantOrderId:i.merchantOrderId,amount:m,currency:i.currency,status:"COMPLETED",reason:(null==a?void 0:a.reason)||"REQUESTED_BY_CUSTOMER"}},u.webhookSecret)}catch(e){console_1.logger.error("ADMIN_GATEWAY_REFUND","Failed to send refund.completed webhook",e)}null==o||o.success(`Refund ${p} created successfully for ${m} ${i.currency}`);return{id:p,paymentId:i.paymentIntentId,amount:m,currency:i.currency,status:"COMPLETED",reason:(null==a?void 0:a.reason)||"REQUESTED_BY_CUSTOMER",description:(null==a?void 0:a.description)||null,createdAt:g.createdAt}};