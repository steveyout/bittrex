"use strict";function getTimeRangeDates(e){const t=new Date;let a,s;switch(e){case"7d":{const e=(t.getDay()+6)%7;a=new Date(t);a.setDate(t.getDate()-e);a.setHours(0,0,0,0);s=new Date(a);s.setDate(a.getDate()+6);s.setHours(23,59,59,999);break}case"30d":default:a=new Date(t.getFullYear(),t.getMonth(),1);s=new Date(t.getFullYear(),t.getMonth()+1,0);s.setHours(23,59,59,999);break;case"90d":{let e=t.getMonth()-2,r=t.getFullYear();if(e<0){e+=12;r-=1}a=new Date(r,e,1);s=new Date(t.getFullYear(),t.getMonth()+1,0);s.setHours(23,59,59,999);break}case"1y":a=new Date(t.getFullYear(),0,1);s=new Date(t.getFullYear(),11,31,23,59,59,999)}return{startDate:a,endDate:s}}async function getTimeSeriesData(e,t,a,s){const r=await db_1.models.stakingPosition.findAll({attributes:[[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("createdAt")),"date"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("amount")),"staked"]],where:{poolId:e,createdAt:{[sequelize_1.Op.gte]:t,[sequelize_1.Op.lte]:a}},group:[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("createdAt"))],raw:!0}),o=await db_1.models.stakingEarningRecord.findAll({attributes:[[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("stakingEarningRecord.createdAt")),"date"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("stakingEarningRecord.amount")),"earnings"]],include:[{model:db_1.models.stakingPosition,as:"position",attributes:[],where:{poolId:e}}],where:{createdAt:{[sequelize_1.Op.gte]:t,[sequelize_1.Op.lte]:a}},group:[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("stakingEarningRecord.createdAt"))],raw:!0}),i=await db_1.models.stakingPosition.findAll({attributes:[[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("createdAt")),"date"],[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.fn)("DISTINCT",(0,sequelize_1.col)("userId"))),"users"]],where:{poolId:e,createdAt:{[sequelize_1.Op.gte]:t,[sequelize_1.Op.lte]:a}},group:[(0,sequelize_1.fn)("DATE",(0,sequelize_1.col)("createdAt"))],raw:!0}),n=new Map,l=new Date(t);for(;l<=a;){const e=l.toISOString().split("T")[0];n.set(e,{date:e,staked:0,earnings:0,users:0});l.setDate(l.getDate()+1)}r.forEach(e=>{const t=e.date,a=n.get(t);a&&(a.staked=Number.parseFloat(e.staked)||0)});o.forEach(e=>{const t=e.date,a=n.get(t);a&&(a.earnings=Number.parseFloat(e.earnings)||0)});i.forEach(e=>{const t=e.date,a=n.get(t);a&&(a.users=Number.parseInt(e.users)||0)});const u=Array.from(n.values()).sort((e,t)=>new Date(e.date).getTime()-new Date(t.date).getTime());if("7d"===s||"30d"===s)return u;if("90d"===s){const e=[];for(let t=0;t<u.length;t+=7){const a=u.slice(t,t+7),s=a[0].date,r=a.reduce((e,t)=>e+t.staked,0),o=a.reduce((e,t)=>e+t.earnings,0),i=a.reduce((e,t)=>e+t.users,0);e.push({date:s,staked:r,earnings:o,users:i})}return e}if("1y"===s){const e={};u.forEach(t=>{const a=t.date.slice(0,7);e[a]||(e[a]={date:a,staked:0,earnings:0,users:0});e[a].staked+=t.staked;e[a].earnings+=t.earnings;e[a].users+=t.users});return Object.values(e).sort((e,t)=>e.date.localeCompare(t.date))}}async function getMetrics(e){const t=await db_1.models.stakingPosition.count({where:{poolId:e,status:"ACTIVE"}}),a=await db_1.models.stakingEarningRecord.findOne({attributes:[[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("stakingEarningRecord.amount")),"totalEarnings"]],include:[{model:db_1.models.stakingPosition,as:"position",attributes:[],where:{poolId:e}}],raw:!0}),s=Number.parseFloat(null==a?void 0:a.totalEarnings)||0,r=await db_1.models.stakingPosition.findOne({attributes:[[(0,sequelize_1.fn)("AVG",(0,sequelize_1.col)("amount")),"avgStakeAmount"]],where:{poolId:e},raw:!0}),o=Number.parseFloat(null==r?void 0:r.avgStakeAmount)||0,i=await db_1.models.stakingPool.findByPk(e,{attributes:["apr"],raw:!0}),n=(null==i?void 0:i.apr)||0,l=await db_1.models.stakingExternalPoolPerformance.findAll({attributes:["apr","profit","totalStaked"],where:{poolId:e},order:[["date","DESC"]],limit:10,raw:!0});let u=0,d=0;if(l.length>0){u=l.reduce((e,t)=>e+Number.parseFloat(t.apr),0)/l.length;d=n>0?u/n:0}return{activePositions:t,totalEarnings:s,avgStakeAmount:o,expectedAPR:n,actualAPR:u,efficiency:d}}async function getDistributions(e,t,a){const s=[{name:"0-10",value:0},{name:"10-50",value:0},{name:"50-100",value:0},{name:"100-500",value:0},{name:"500+",value:0}];(await db_1.models.stakingEarningRecord.findAll({attributes:["amount"],include:[{model:db_1.models.stakingPosition,as:"position",attributes:[],where:{poolId:e}}],where:{createdAt:{[sequelize_1.Op.gte]:t,[sequelize_1.Op.lte]:a}},raw:!0})).forEach(e=>{const t=Number.parseFloat(e.amount);t<=10?s[0].value+=1:t<=50?s[1].value+=1:t<=100?s[2].value+=1:t<=500?s[3].value+=1:s[4].value+=1});const r=(await db_1.models.stakingEarningRecord.findAll({attributes:["type",[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("stakingEarningRecord.amount")),"value"]],include:[{model:db_1.models.stakingPosition,as:"position",attributes:[],where:{poolId:e}}],where:{createdAt:{[sequelize_1.Op.gte]:t,[sequelize_1.Op.lte]:a}},group:["type"],raw:!0})).map(e=>({name:e.type,value:Number.parseFloat(e.value)||0})),o=await db_1.models.stakingPosition.findAll({attributes:["userId",[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.col)("id")),"positionCount"]],where:{poolId:e},group:["userId"],raw:!0}),i=[{name:"1 Position",value:0},{name:"2 Positions",value:0},{name:"3+ Positions",value:0}];o.forEach(e=>{const t=Number.parseInt(e.positionCount);1===t?i[0].value+=1:2===t?i[1].value+=1:i[2].value+=1});return{earningsDistribution:s,earningsByType:r,userRetention:i}}async function getPerformance(e,t,a,s){const r=await db_1.models.stakingExternalPoolPerformance.findAll({attributes:["date","apr"],where:{poolId:e,date:{[sequelize_1.Op.gte]:t,[sequelize_1.Op.lte]:a}},order:[["date","ASC"]],raw:!0}),o=new Map;r.forEach(e=>{const t=new Date(e.date).toISOString().split("T")[0];o.set(t,Number.parseFloat(e.apr)||0)});const i=[],n=new Date(t);for(;n<=a;){const e=n.toISOString().split("T")[0];i.push({date:e,apr:o.get(e)||0});n.setDate(n.getDate()+1)}const l=await db_1.models.stakingPool.findByPk(e,{attributes:["apr"],raw:!0}),u=(null==l?void 0:l.apr)||0,d=e=>({aprOverTime:e.map(e=>({date:e.date,expectedAPR:u,actualAPR:e.apr})),efficiencyTrend:e.map(e=>({date:e.date,efficiency:u>0?e.apr/u:0}))});if("7d"===s||"30d"===s)return d(i);if("90d"===s){const e=[];for(let t=0;t<i.length;t+=7){const a=i.slice(t,t+7),s=a[0].date,r=a.reduce((e,t)=>e+t.apr,0)/a.length;e.push({date:s,apr:r})}return d(e)}if("1y"===s){const e={};i.forEach(t=>{const a=t.date.slice(0,7);e[a]||(e[a]={date:a,sumApr:0,count:0});e[a].sumApr+=t.apr;e[a].count+=1});return d(Object.values(e).map(e=>({date:e.date,apr:e.count>0?e.sumApr/e.count:0})).sort((e,t)=>e.date.localeCompare(t.date)))}return d(i)}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),sequelize_1=require("sequelize");exports.metadata={summary:"Get Pool Analytics",description:"Retrieves analytics data for a specific staking pool.",operationId:"getPoolAnalytics",tags:["Staking","Admin","Pools","Analytics"],requiresAuth:!0,logModule:"ADMIN_STAKE",logTitle:"Get Pool Analytics",parameters:[{index:0,name:"id",in:"path",required:!0,schema:{type:"string"},description:"Pool ID"},{name:"timeRange",in:"query",required:!1,schema:{type:"string",enum:["7d","30d","90d","1y"]},description:"Time range for analytics data"}],responses:{200:{description:"Pool analytics retrieved successfully",content:{"application/json":{schema:{type:"object"}}}},401:{description:"Unauthorized"},404:{description:"Pool not found"},500:{description:"Internal Server Error"}},permission:"view.staking.pool"};exports.default=async e=>{const{user:t,params:a,query:s,ctx:r}=e;if(!(null==t?void 0:t.id))throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"});const o=a.id;if(!o)throw(0,error_1.createError)({statusCode:400,message:"Pool ID is required"});const i=(null==s?void 0:s.timeRange)||"30d",{startDate:n,endDate:l}=getTimeRangeDates(i);try{null==r||r.step("Fetching data");if(!await db_1.models.stakingPool.findByPk(o))throw(0,error_1.createError)({statusCode:404,message:"Pool not found"});const e=await getTimeSeriesData(o,n,l,i),t=await getMetrics(o),a=await getDistributions(o,n,l),s=await getPerformance(o,n,l,i);null==r||r.success("Pool analytics retrieved successfully");return{timeSeriesData:e,metrics:t,distributions:a,performance:s}}catch(e){if(404===e.statusCode)throw e;console.error(`Error fetching analytics for pool ${o}:`,e);throw(0,error_1.createError)({statusCode:500,message:e.message||"Failed to fetch pool analytics"})}};