"use strict";async function executeOrder(e){var t,r,o,i,n,s,a,c,l,u;const{userId:d,symbol:p,side:f,type:g,amount:m,price:_}=e;try{const[e,y]=p.split("/"),b=await db_1.models.ecosystemMarket.findOne({where:{currency:e,pair:y}});if(!b)return{success:!1,error:`Market not found: ${p}`};const P=b,v=Number((null===(o=null===(r=null===(t=P.metadata)||void 0===t?void 0:t.limits)||void 0===r?void 0:r.amount)||void 0===o?void 0:o.min)||0),O=Number((null===(s=null===(n=null===(i=P.metadata)||void 0===i?void 0:i.limits)||void 0===n?void 0:n.amount)||void 0===s?void 0:s.max)||Number.MAX_SAFE_INTEGER);if(m<v)return{success:!1,error:`Amount below minimum: ${v}`};if(m>O)return{success:!1,error:`Amount above maximum: ${O}`};let S=_;if("MARKET"===g){const{asks:e,bids:t}=await(0,queries_1.getOrderBook)(p);"BUY"===f&&e&&e.length>0?S=e[0][0]:"SELL"===f&&t&&t.length>0&&(S=t[0][0])}const h=Number((null===(c=null===(a=P.metadata)||void 0===a?void 0:a.precision)||void 0===c?void 0:c.price)||8),w=Number((null===(l=P.metadata)||void 0===l?void 0:l.taker)||.1),x=parseFloat((m*S*w/100).toFixed(h)),k="BUY"===f?parseFloat((m*S+x).toFixed(h)):m,T="BUY"===f?y:e,A=await(0,wallet_1.getWalletByUserIdAndCurrency)(d,T);if(!A)return{success:!1,error:`Wallet not found: ${T}`};const L=parseFloat(A.balance.toString())-parseFloat((null===(u=A.inOrder)||void 0===u?void 0:u.toString())||"0");if(L<k)return{success:!1,error:`Insufficient balance: ${L} < ${k}`};const B=await(0,queries_1.createOrder)({userId:d,symbol:p,amount:(0,blockchain_1.toBigIntFloat)(m),price:(0,blockchain_1.toBigIntFloat)(S),cost:(0,blockchain_1.toBigIntFloat)(k),type:g,side:f,fee:(0,blockchain_1.toBigIntFloat)(x),feeCurrency:y});await(0,wallet_1.updateWalletBalance)(A,k,"subtract",`ct_exec_order_${B.id}`);return{success:!0,orderId:B.id,executedAmount:m,executedPrice:S,fee:x}}catch(e){console_1.logger.error("COPY_TRADING","Failed to execute order",e);return{success:!1,error:e.message}}}async function cancelCopyOrder(e,t){try{const r=(await(0,queries_1.getOrdersByUserId)(t)).find(t=>t.id===e);if(!r)return{success:!1,error:"Order not found"};const o=r.createdAt instanceof Date?r.createdAt.toISOString():String(r.createdAt);await(0,queries_1.cancelOrderByUuid)(t,e,o,r.symbol,r.price,r.side,r.remaining||r.amount);return{success:!0}}catch(e){console_1.logger.error("COPY_TRADING","Failed to cancel order",e);return{success:!1,error:e.message}}}async function checkPositionSize(e,t,r){const o=await db_1.models.copyTradingFollower.findByPk(e);if(!o)return{passed:!1,reason:"Follower not found"};const i=o,n=t*r;if(i.maxPositionSize&&t>i.maxPositionSize)return{passed:!0,adjustedAmount:i.maxPositionSize,reason:"Adjusted to max position size"};const s=i.allocatedAmount-i.usedAmount;return n>s?{passed:!0,adjustedAmount:s/r,reason:"Adjusted to available balance"}:{passed:!0}}async function checkStopLevels(e,t){const r=await db_1.models.copyTradingTrade.findByPk(e,{include:[{model:db_1.models.copyTradingFollower,as:"follower"}]});if(!r)return{triggerStopLoss:!1,triggerTakeProfit:!1};const o=r,i=o.follower;if(!i)return{triggerStopLoss:!1,triggerTakeProfit:!1};const n=o.executedPrice||o.price,s="BUY"===o.side;let a,c;i.stopLossPercent&&(a=s?n*(1-i.stopLossPercent/100):n*(1+i.stopLossPercent/100));i.takeProfitPercent&&(c=s?n*(1+i.takeProfitPercent/100):n*(1-i.takeProfitPercent/100));return{triggerStopLoss:!!a&&(s?t<=a:t>=a),triggerTakeProfit:!!c&&(s?t>=c:t<=c),stopLossPrice:a,takeProfitPrice:c}}async function monitorStopLevels(){let e=0,t=0;try{const r=await db_1.models.copyTradingTrade.findAll({where:{followerId:{[sequelize_1.Op.ne]:null},status:"OPEN"},include:[{model:db_1.models.copyTradingFollower,as:"follower",where:{[sequelize_1.Op.or]:[{stopLossPercent:{[sequelize_1.Op.ne]:null}},{takeProfitPercent:{[sequelize_1.Op.ne]:null}}]}}]});for(const o of r){e++;const[r,i]=o.symbol.split("/"),{asks:n,bids:s}=await(0,queries_1.getOrderBook)(o.symbol),a="BUY"===o.side?s&&s.length>0?s[0][0]:o.price:n&&n.length>0?n[0][0]:o.price,{triggerStopLoss:c,triggerTakeProfit:l}=await checkStopLevels(o.id,a);if(c||l){t++;const{closeTrade:e}=await Promise.resolve().then(()=>__importStar(require("./fillMonitor")));await e(o.id,a);await(0,index_1.createAuditLog)({entityType:"copyTradingTrade",entityId:o.id,action:c?"STOP_LOSS_TRIGGERED":"TAKE_PROFIT_TRIGGERED",metadata:{currentPrice:a,entryPrice:o.executedPrice||o.price}})}}return{processed:e,triggered:t}}catch(r){console_1.logger.error("COPY_TRADING","Failed to monitor stop levels",r);return{processed:e,triggered:t}}}async function calculateExpectedSlippage(e,t,r,o){try{const{asks:i,bids:n}=await(0,queries_1.getOrderBook)(e),s="BUY"===t?i:n;if(!s||0===s.length)return{slippage:0,effectivePrice:o};let a=r,c=0;for(const[e,t]of s){const r=Math.min(a,t);c+=r*e;a-=r;if(a<=0)break}const l=c/r,u=(l-o)/o*100;return{slippage:Math.abs(u),effectivePrice:l}}catch(e){return{slippage:0,effectivePrice:o}}}async function checkSlippageLimit(e,t,r,o,i=2){const{slippage:n,effectivePrice:s}=await calculateExpectedSlippage(e,t,r,o);return{acceptable:n<=i,expectedSlippage:n}}async function getOrderStatus(){try{return null}catch(e){return null}}async function syncTradeStatus(e){try{const t=await db_1.models.copyTradingTrade.findByPk(e);if(!t)return!1;const r=t,o=await getOrderStatus(r.leaderOrderId);if(o){await r.update({executedAmount:o.filledAmount,executedPrice:o.filledPrice,fee:o.fee,status:"FILLED"===o.status?"OPEN":r.status});return!0}return!1}catch(e){console_1.logger.error("COPY_TRADING","Failed to sync trade status",e);return!1}}var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}});Object.defineProperty(e,o,i)}:function(e,t,r,o){void 0===o&&(o=r);e[o]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(){var e=function(t){e=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t};return e(t)};return function(t){if(t&&t.__esModule)return t;var r={};if(null!=t)for(var o=e(t),i=0;i<o.length;i++)"default"!==o[i]&&__createBinding(r,t,o[i]);__setModuleDefault(r,t);return r}}();Object.defineProperty(exports,"__esModule",{value:!0});exports.executeOrder=executeOrder;exports.cancelCopyOrder=cancelCopyOrder;exports.checkPositionSize=checkPositionSize;exports.checkStopLevels=checkStopLevels;exports.monitorStopLevels=monitorStopLevels;exports.calculateExpectedSlippage=calculateExpectedSlippage;exports.checkSlippageLimit=checkSlippageLimit;exports.getOrderStatus=getOrderStatus;exports.syncTradeStatus=syncTradeStatus;const db_1=require("@b/db"),sequelize_1=require("sequelize"),console_1=require("@b/utils/console"),wallet_1=require("@b/api/(ext)/ecosystem/utils/wallet"),queries_1=require("@b/api/(ext)/ecosystem/utils/scylla/queries"),blockchain_1=require("@b/api/(ext)/ecosystem/utils/blockchain"),index_1=require("./index");