"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const utils_1=require("@b/api/finance/wallet/utils"),matchingEngine_1=require("@b/api/(ext)/futures/utils/matchingEngine");let fromBigInt,updateWalletBalance;try{const e=require("@b/api/(ext)/ecosystem/utils/blockchain");fromBigInt=e.fromBigInt}catch(e){}try{const e=require("@b/api/(ext)/ecosystem/utils/wallet");updateWalletBalance=e.updateWalletBalance}catch(e){}const error_1=require("@b/utils/error"),query_1=require("@b/utils/query"),order_1=require("@b/api/(ext)/futures/utils/queries/order");exports.metadata={summary:"Cancels an existing futures trading order",description:"Cancels an open futures trading order and refunds the unfulfilled amount.",operationId:"cancelFuturesOrder",tags:["Futures","Orders"],logModule:"FUTURES",logTitle:"Cancel futures order",parameters:[{index:0,name:"id",in:"path",required:!0,schema:{type:"string",description:"UUID of the order"}},{name:"timestamp",in:"query",required:!0,schema:{type:"string",description:"Timestamp of the order"}}],responses:{200:{description:"Order cancelled successfully",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Success message"}}}}}},401:query_1.unauthorizedResponse,404:(0,query_1.notFoundMetadataResponse)("Order"),500:query_1.serverErrorResponse},requiresAuth:!0};exports.default=async e=>{var r,t,l,a,i,n,s,o,d,u,c,p,m,g;const{params:f,query:v,user:h,ctx:y}=e;null===(r=null==y?void 0:y.step)||void 0===r||r.call(y,"Validating user authentication");if(!(null==h?void 0:h.id)){null===(t=null==y?void 0:y.fail)||void 0===t||t.call(y,"User not authenticated");throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"})}const{id:q}=f,{timestamp:_}=v;null===(l=null==y?void 0:y.step)||void 0===l||l.call(y,"Validating request parameters");if(!q||!_){null===(a=null==y?void 0:y.fail)||void 0===a||a.call(y,"Missing order ID or timestamp");throw(0,error_1.createError)({statusCode:400,message:"Invalid request parameters"})}try{null===(i=null==y?void 0:y.step)||void 0===i||i.call(y,`Fetching order ${q}`);const e=await(0,order_1.getOrderByUuid)(h.id,q,_);if(!e){null===(n=null==y?void 0:y.fail)||void 0===n||n.call(y,"Order not found");throw(0,error_1.createError)({statusCode:404,message:"Order not found"})}if("OPEN"!==e.status){null===(s=null==y?void 0:y.fail)||void 0===s||s.call(y,"Order is not open");throw(0,error_1.createError)({statusCode:400,message:"Order is not open"})}null===(o=null==y?void 0:y.step)||void 0===o||o.call(y,`Cancelling order for ${e.symbol}`);await(0,order_1.cancelOrderByUuid)(h.id,q,_,e.symbol,BigInt(e.price),e.side,BigInt(e.amount));const[r,t]=e.symbol.split("/"),l=fromBigInt(e.cost)+fromBigInt(e.fee),a="BUY"===e.side?t:r;null===(d=null==y?void 0:y.step)||void 0===d||d.call(y,`Fetching ${a} wallet for refund`);const g=await(0,utils_1.getWallet)(h.id,"FUTURES",a,!1,y);if(!g){null===(u=null==y?void 0:y.fail)||void 0===u||u.call(y,`${a} wallet not found`);throw(0,error_1.createError)({statusCode:404,message:`${a} wallet not found`})}null===(c=null==y?void 0:y.step)||void 0===c||c.call(y,`Refunding ${l} ${a}`);await updateWalletBalance(g,l,"add");null===(p=null==y?void 0:y.step)||void 0===p||p.call(y,"Notifying matching engine of cancellation");const f=await matchingEngine_1.FuturesMatchingEngine.getInstance();await f.handleOrderCancellation(q,e.symbol);null===(m=null==y?void 0:y.success)||void 0===m||m.call(y,`Order ${q} cancelled and refunded successfully`);return{message:"Order cancelled and balance refunded successfully"}}catch(e){null===(g=null==y?void 0:y.fail)||void 0===g||g.call(y,`Failed to cancel order: ${e.message}`);throw(0,error_1.createError)({statusCode:500,message:`Failed to cancel order: ${e.message}`})}};