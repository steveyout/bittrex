"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const error_1=require("@b/utils/error");let fromBigInt,updateWalletBalance;try{const e=require("@b/api/(ext)/ecosystem/utils/blockchain");fromBigInt=e.fromBigInt;const t=require("@b/api/(ext)/ecosystem/utils/wallet");updateWalletBalance=t.updateWalletBalance}catch(e){}const query_1=require("@b/utils/query"),positions_1=require("@b/api/(ext)/futures/utils/queries/positions"),utils_1=require("@b/api/finance/wallet/utils");exports.metadata={summary:"Closes an open futures position",description:"Closes an open futures position for the logged-in user.",operationId:"closeFuturesPosition",tags:["Futures","Positions"],logModule:"FUTURES",logTitle:"Close futures position",requestBody:{required:!0,content:{"application/json":{schema:{type:"object",properties:{currency:{type:"string",description:"Currency symbol (e.g., BTC)"},pair:{type:"string",description:"Pair symbol (e.g., USDT)"},side:{type:"string",description:"Position side, either buy or sell"}},required:["currency","pair","side"]}}}},responses:{200:{description:"Position closed successfully",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string",description:"Success message"}}}}}},401:query_1.unauthorizedResponse,404:(0,query_1.notFoundMetadataResponse)("Position"),500:query_1.serverErrorResponse},requiresAuth:!0};exports.default=async e=>{var t,o,s,i,l,a,r,n,u,c,d,p,g,f;const{body:v,user:m,ctx:y}=e;null===(t=null==y?void 0:y.step)||void 0===t||t.call(y,"Validating user authentication");if(!(null==m?void 0:m.id)){null===(o=null==y?void 0:y.fail)||void 0===o||o.call(y,"User not authenticated");throw(0,error_1.createError)({statusCode:401,message:"Unauthorized"})}const{currency:h,pair:b,side:q}=v;null===(s=null==y?void 0:y.step)||void 0===s||s.call(y,"Validating request parameters");if(!h||!b||!q){null===(i=null==y?void 0:y.fail)||void 0===i||i.call(y,"Missing required parameters");throw(0,error_1.createError)({statusCode:400,message:"Invalid request parameters"})}const _=`${h}/${b}`;try{null===(l=null==y?void 0:y.step)||void 0===l||l.call(y,`Fetching position for ${_} (${q})`);const e=await(0,positions_1.getPosition)(m.id,_,q);if(!e){null===(a=null==y?void 0:y.fail)||void 0===a||a.call(y,"Position not found");throw(0,error_1.createError)({statusCode:404,message:"Position not found"})}if("OPEN"!==e.status){null===(r=null==y?void 0:y.fail)||void 0===r||r.call(y,"Position is not open");throw(0,error_1.createError)({statusCode:400,message:"Position is not open"})}null===(n=null==y?void 0:y.step)||void 0===n||n.call(y,"Calculating final balance change");const t=calculateFinalBalanceChange(e);null===(u=null==y?void 0:y.step)||void 0===u||u.call(y,`Fetching ${b} wallet`);const o=await(0,utils_1.getWallet)(e.userId,"FUTURES",_.split("/")[1],!1,y);if(o){if(!updateWalletBalance){null===(c=null==y?void 0:y.fail)||void 0===c||c.call(y,"Ecosystem extension not available");throw(0,error_1.createError)({statusCode:500,message:"Ecosystem extension not available for wallet operations"})}null===(d=null==y?void 0:y.step)||void 0===d||d.call(y,`Updating wallet balance by ${t>0?"+":""}${t}`);t>0?await updateWalletBalance(o,t,"add"):await updateWalletBalance(o,Math.abs(t),"subtract")}null===(p=null==y?void 0:y.step)||void 0===p||p.call(y,"Updating position status to CLOSED");await(0,positions_1.updatePositionStatus)(e.userId,e.id,"CLOSED");null===(g=null==y?void 0:y.success)||void 0===g||g.call(y,`Position closed successfully for ${_}`);return{message:"Position closed and balance updated successfully"}}catch(e){null===(f=null==y?void 0:y.fail)||void 0===f||f.call(y,`Failed to close position: ${e.message}`);throw(0,error_1.createError)({statusCode:500,message:`Failed to close position: ${e.message}`})}};const calculateFinalBalanceChange=e=>{if(!fromBigInt)throw(0,error_1.createError)({statusCode:500,message:"Ecosystem extension not available for number conversion"});return fromBigInt(e.entryPrice)*fromBigInt(e.amount)+fromBigInt(e.unrealizedPnl)};