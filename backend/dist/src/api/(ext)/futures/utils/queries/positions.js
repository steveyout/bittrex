"use strict";async function getPosition(e,t,s){if(!client||!scyllaFuturesKeyspace)throw(0,error_1.createError)({statusCode:503,message:"Ecosystem extension not available"});const r=`\n    SELECT * FROM ${scyllaFuturesKeyspace}.positions_by_symbol\n    WHERE symbol = ? AND "userId" = ? AND side = ? AND status = 'OPEN' ALLOW FILTERING;\n  `,o=[t,e,s];try{const e=await client.execute(r,o,{prepare:!0});if(e.rows.length>0){const t=e.rows[0];return{id:(0,order_1.uuidToString)(t.id),userId:(0,order_1.uuidToString)(t.userId),symbol:t.symbol,side:t.side,entryPrice:BigInt(t.entryPrice),amount:BigInt(t.amount),leverage:Number(t.leverage),unrealizedPnl:BigInt(t.unrealizedPnl),stopLossPrice:t.stopLossPrice?BigInt(t.stopLossPrice):void 0,takeProfitPrice:t.takeProfitPrice?BigInt(t.takeProfitPrice):void 0,status:t.status,createdAt:new Date(t.createdAt),updatedAt:new Date(t.updatedAt)}}return null}catch(e){console_1.logger.error("POSITIONS","Failed to fetch position",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to fetch position: ${e.message}`})}}async function getPositions(e,t,s){if(!client||!scyllaFuturesKeyspace)throw(0,error_1.createError)({statusCode:503,message:"Ecosystem extension not available"});let r=`\n    SELECT * FROM ${scyllaFuturesKeyspace}.position\n    WHERE "userId" = ?\n  `;const o=[e];if(t){r+=" AND symbol = ?";o.push(t)}if(s){r+=" AND status = ?";o.push(s)}r+=" ALLOW FILTERING;";try{return(await client.execute(r,o,{prepare:!0})).rows.map(e=>({id:(0,order_1.uuidToString)(e.id),userId:(0,order_1.uuidToString)(e.userId),symbol:e.symbol,side:e.side,entryPrice:BigInt(e.entryPrice),amount:BigInt(e.amount),leverage:Number(e.leverage),unrealizedPnl:BigInt(e.unrealizedPnl),stopLossPrice:e.stopLossPrice?BigInt(e.stopLossPrice):void 0,takeProfitPrice:e.takeProfitPrice?BigInt(e.takeProfitPrice):void 0,status:e.status,createdAt:new Date(e.createdAt),updatedAt:new Date(e.updatedAt)}))}catch(e){console_1.logger.error("POSITIONS","Failed to fetch positions",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to fetch positions: ${e.message}`})}}async function getAllOpenPositions(){if(!client||!scyllaFuturesKeyspace)throw(0,error_1.createError)({statusCode:503,message:"Ecosystem extension not available"});const e=`\n    SELECT * FROM ${scyllaFuturesKeyspace}.position WHERE status = 'OPEN' ALLOW FILTERING;\n  `;try{return(await client.execute(e,[],{prepare:!0})).rows.map(e=>({id:(0,order_1.uuidToString)(e.id),userId:(0,order_1.uuidToString)(e.userId),symbol:e.symbol,side:e.side,entryPrice:BigInt(e.entryPrice),amount:BigInt(e.amount),leverage:Number(e.leverage),unrealizedPnl:BigInt(e.unrealizedPnl),stopLossPrice:e.stopLossPrice?BigInt(e.stopLossPrice):void 0,takeProfitPrice:e.takeProfitPrice?BigInt(e.takeProfitPrice):void 0,status:e.status,createdAt:new Date(e.createdAt),updatedAt:new Date(e.updatedAt)}))}catch(e){console_1.logger.error("POSITIONS","Failed to fetch open positions",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to fetch open positions: ${e.message}`})}}async function createPosition(e,t,s,r,o,i,a,n,c){if(!client||!scyllaFuturesKeyspace)throw(0,error_1.createError)({statusCode:503,message:"Ecosystem extension not available"});const u=`\n    INSERT INTO ${scyllaFuturesKeyspace}.position (id, "userId", symbol, side, "entryPrice", amount, leverage, "unrealizedPnl", "stopLossPrice", "takeProfitPrice", status, "createdAt", "updatedAt")\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'OPEN', ?, ?);\n  `,l=[(0,passwords_1.makeUuid)(),e,t,s,r.toString(),o.toString(),i,a.toString(),(null==n?void 0:n.toString())||null,(null==c?void 0:c.toString())||null,new Date,new Date];try{await client.execute(u,l,{prepare:!0})}catch(e){console_1.logger.error("POSITIONS","Failed to create position",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to create position: ${e.message}`})}}async function updatePositionInDB(e,t,s,r,o,i,a){if(!client||!scyllaFuturesKeyspace)throw(0,error_1.createError)({statusCode:503,message:"Ecosystem extension not available"});const n=`\n    UPDATE ${scyllaFuturesKeyspace}.position\n    SET "entryPrice" = ?, amount = ?, "unrealizedPnl" = ?, "stopLossPrice" = ?, "takeProfitPrice" = ?, "updatedAt" = ?\n    WHERE "userId" = ? AND id = ?;\n  `,c=[s.toString(),r.toString(),o.toString(),(null==i?void 0:i.toString())||null,(null==a?void 0:a.toString())||null,new Date,e,t];try{await client.execute(n,c,{prepare:!0})}catch(e){console_1.logger.error("POSITIONS","Failed to update position",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to update position: ${e.message}`})}}async function updatePositionStatus(e,t,s){if(!client||!scyllaFuturesKeyspace)throw(0,error_1.createError)({statusCode:503,message:"Ecosystem extension not available"});const r=`\n    UPDATE ${scyllaFuturesKeyspace}.position\n    SET status = ?, "updatedAt" = ?\n    WHERE "userId" = ? AND id = ?;\n  `,o=[s,new Date,e,t];try{await client.execute(r,o,{prepare:!0})}catch(e){console_1.logger.error("POSITIONS","Failed to update position status",e);throw(0,error_1.createError)({statusCode:500,message:`Failed to update position status: ${e.message}`})}}Object.defineProperty(exports,"__esModule",{value:!0});exports.getPosition=getPosition;exports.getPositions=getPositions;exports.getAllOpenPositions=getAllOpenPositions;exports.createPosition=createPosition;exports.updatePositionInDB=updatePositionInDB;exports.updatePositionStatus=updatePositionStatus;const error_1=require("@b/utils/error");let client,scyllaFuturesKeyspace;try{const e=require("@b/api/(ext)/ecosystem/utils/scylla/client");client=e.default;scyllaFuturesKeyspace=e.scyllaFuturesKeyspace}catch(e){}const passwords_1=require("@b/utils/passwords"),order_1=require("./order"),console_1=require("@b/utils/console");