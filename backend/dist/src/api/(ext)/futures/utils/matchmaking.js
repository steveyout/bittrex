"use strict";function addTradeToOrder(e,r){let t=[];if(e.trades)try{if("string"==typeof e.trades){t=JSON.parse(e.trades);Array.isArray(t)||"string"!=typeof t||(t=JSON.parse(t))}else if(Array.isArray(e.trades))t=e.trades;else{console_1.logger.error("FUTURES","Invalid trades format in order",new Error("Invalid trades format"));t=[]}}catch(e){console_1.logger.error("FUTURES","Error parsing trades",e);t=[]}const i=[...t,r].sort((e,r)=>e.timestamp-r.timestamp);e.trades=JSON.stringify(i,BigIntReplacer||void 0);return e.trades}function validateOrder(e){if(!(e&&e.id&&e.userId&&e.symbol&&e.type&&e.side&&"bigint"==typeof e.price&&"bigint"==typeof e.amount&&"bigint"==typeof e.filled&&"bigint"==typeof e.remaining&&"bigint"==typeof e.cost&&"bigint"==typeof e.fee&&e.feeCurrency&&e.status&&e.createdAt instanceof Date&&e.updatedAt instanceof Date)){console_1.logger.error("FUTURES","Order validation failed",new Error("Order validation failed"));return!1}return!0}function sortOrders(e,r){return e.sort((e,t)=>{const i=Number(r?t.price-e.price:e.price-t.price);return 0!==i?i:e.createdAt<t.createdAt?-1:e.createdAt>t.createdAt?1:0})}Object.defineProperty(exports,"__esModule",{value:!0});exports.filterAndSortOrders=exports.processMatchedOrders=exports.matchAndCalculateOrders=void 0;exports.addTradeToOrder=addTradeToOrder;exports.validateOrder=validateOrder;exports.sortOrders=sortOrders;let OrderBook,fromBigInt,fromBigIntMultiply,BigIntReplacer;try{OrderBook=require("../../ecosystem/utils/scylla/queries").OrderBook;const e=require("../../ecosystem/utils/blockchain");fromBigInt=e.fromBigInt;fromBigIntMultiply=e.fromBigIntMultiply;BigIntReplacer=e.BigIntReplacer}catch(e){}const ws_1=require("./ws"),console_1=require("@b/utils/console"),position_1=require("./position"),matchAndCalculateOrders=async(e,r)=>{if(!fromBigInt||!fromBigIntMultiply){console_1.logger.warn("FUTURES","Ecosystem extension not available for order matching");return{matchedOrders:[],bookUpdates:{bids:{},asks:{}}}}const t=[],i={bids:{},asks:{}},s=new Set,o=(0,exports.filterAndSortOrders)(e,"BUY",!0),a=(0,exports.filterAndSortOrders)(e,"SELL",!1);let n=0,d=0;for(;n<o.length&&d<a.length;){const e=o[n],c=a[d];if(s.has(e.id)||s.has(c.id)){s.has(e.id)&&n++;s.has(c.id)&&d++;continue}let p=!1;"LIMIT"===e.type&&"LIMIT"===c.type?p="BUY"===e.side&&e.price>=c.price||"SELL"===e.side&&c.price>=e.price:"MARKET"!==e.type&&"MARKET"!==c.type||(p=!0);if(p){s.add(e.id);s.add(c.id);try{const t="MARKET"===e.type?c.price:"MARKET"===c.type?e.price:c.price;await(0,exports.processMatchedOrders)(e,c,r,i,t)}catch(e){console_1.logger.error("FUTURES","Failed to process matched orders",e)}t.push(e,c);"LIMIT"===e.type&&e.remaining===BigInt(0)&&n++;"LIMIT"===c.type&&c.remaining===BigInt(0)&&d++;"MARKET"===e.type&&e.remaining>BigInt(0)&&s.delete(e.id);"MARKET"===c.type&&c.remaining>BigInt(0)&&s.delete(c.id)}else{"MARKET"!==e.type&&BigInt(e.price)<BigInt(c.price)&&n++;"MARKET"!==c.type&&BigInt(c.price)>BigInt(e.price)&&d++}}return{matchedOrders:t,bookUpdates:i}};exports.matchAndCalculateOrders=matchAndCalculateOrders;const processMatchedOrders=async(e,r,t,i,s)=>{const o=BigInt(e.remaining)<BigInt(r.remaining)?BigInt(e.remaining):BigInt(r.remaining);updateOrderBook(i,e,t,o);updateOrderBook(i,r,t,o);[e,r].forEach(e=>{e.filled+=o;e.remaining-=o;e.status=e.remaining===BigInt(0)?"CLOSED":"OPEN"});try{await(0,position_1.updatePositions)(e,r,o,s)}catch(e){console_1.logger.error("FUTURES","Failed to update wallet balances",e)}const a={id:`${e.id}`,amount:fromBigInt(o),price:fromBigInt(s),cost:fromBigIntMultiply(o,s),side:e.side,timestamp:Date.now()},n={id:`${r.id}`,amount:fromBigInt(o),price:fromBigInt(s),cost:fromBigIntMultiply(o,s),side:r.side,timestamp:Date.now()};addTradeToOrder(e,a);addTradeToOrder(r,n);const d=[a,n];(0,ws_1.handleTradesBroadcast)(e.symbol,d);await handleStopLossTakeProfit(e,s);await handleStopLossTakeProfit(r,s)};exports.processMatchedOrders=processMatchedOrders;const handleStopLossTakeProfit=async(e,r)=>{const t=r;if(e.stopLossPrice&&e.remaining>BigInt(0)){if("BUY"===e.side?t<=e.stopLossPrice:t>=e.stopLossPrice){e.status="CLOSED";e.remaining=BigInt(0);(0,ws_1.handleTradesBroadcast)(e.symbol,[{...e,status:"STOP_LOSS_TRIGGERED",timestamp:Date.now()}])}}if(e.takeProfitPrice&&e.remaining>BigInt(0)){if("BUY"===e.side?t>=e.takeProfitPrice:t<=e.takeProfitPrice){e.status="CLOSED";e.remaining=BigInt(0);(0,ws_1.handleTradesBroadcast)(e.symbol,[{...e,status:"TAKE_PROFIT_TRIGGERED",timestamp:Date.now()}])}}},updateOrderBook=(e,r,t,i)=>{const s=r.price.toString(),o="BUY"===r.side?"bids":"asks";t[o][s]&&(t[o][s]-=i);e[o][s]=t[o][s]},filterAndSortOrders=(e,r,t)=>e.filter(e=>e.side===r).sort((e,r)=>t?Number(r.price)-Number(e.price)||e.createdAt.getTime()-r.createdAt.getTime():Number(e.price)-Number(r.price)||e.createdAt.getTime()-r.createdAt.getTime()).filter(e=>!t||BigInt(e.price)>=BigInt(0));exports.filterAndSortOrders=filterAndSortOrders;