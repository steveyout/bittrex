"use strict";async function sendLiquidationWarningEmail(i,e,t,a){const n={TO:i.email,FIRSTNAME:i.firstName,SYMBOL:e.symbol,MARGIN:t.toFixed(2),LEVERAGE:e.leverage,ENTRY_PRICE:fromBigInt?fromBigInt(e.entryPrice):e.entryPrice,CURRENT_PRICE:a};await emails_1.emailQueue.add({emailData:n,emailType:"LiquidationWarning"})}async function sendPartialLiquidationNotificationEmail(i,e,t){const a={TO:i.email,FIRSTNAME:i.firstName,SYMBOL:e.symbol,LEVERAGE:e.leverage,ENTRY_PRICE:fromBigInt?fromBigInt(e.entryPrice):e.entryPrice,CURRENT_PRICE:t};await emails_1.emailQueue.add({emailData:a,emailType:"PartialLiquidationNotification"})}async function sendLiquidationNotificationEmail(i,e,t){const a={TO:i.email,FIRSTNAME:i.firstName,SYMBOL:e.symbol,LEVERAGE:e.leverage,ENTRY_PRICE:fromBigInt?fromBigInt(e.entryPrice):e.entryPrice,CURRENT_PRICE:t};await emails_1.emailQueue.add({emailData:a,emailType:"LiquidationNotification"})}Object.defineProperty(exports,"__esModule",{value:!0});exports.sendWarningEmail=exports.liquidatePosition=exports.checkForLiquidation=void 0;exports.sendLiquidationWarningEmail=sendLiquidationWarningEmail;exports.sendPartialLiquidationNotificationEmail=sendPartialLiquidationNotificationEmail;exports.sendLiquidationNotificationEmail=sendLiquidationNotificationEmail;let fromBigInt,toBigIntFloat,client,scyllaFuturesKeyspace,getWalletByUserIdAndCurrency,updateWalletBalance;try{const i=require("@b/api/(ext)/ecosystem/utils/blockchain");fromBigInt=i.fromBigInt;toBigIntFloat=i.toBigIntFloat;const e=require("@b/api/(ext)/ecosystem/utils/scylla/client");client=e.default;scyllaFuturesKeyspace=e.scyllaFuturesKeyspace;const t=require("@b/api/(ext)/ecosystem/utils/wallet");getWalletByUserIdAndCurrency=t.getWalletByUserIdAndCurrency;updateWalletBalance=t.updateWalletBalance}catch(i){}const emails_1=require("../../../../utils/emails"),db_1=require("@b/db"),ws_1=require("./ws"),error_1=require("@b/utils/error"),calculateMargin=(i,e)=>{if(!toBigIntFloat)throw(0,error_1.createError)({statusCode:500,message:"Ecosystem extension not available"});const t=toBigIntFloat(e),a=i.entryPrice,n=BigInt(i.leverage);if(a===BigInt(0))throw(0,error_1.createError)({statusCode:400,message:"Entry price cannot be zero"});const o=a/n,r=("BUY"===i.side?t-a:a-t)*BigInt(1e18)/o;return Number(r)/1e18},checkForLiquidation=async(i,e)=>{if(!toBigIntFloat){console.warn("Ecosystem extension not available for liquidation checks");return}const t=calculateMargin(i,e);t<=-.8&&t>-1?await(0,exports.liquidatePosition)(i,e,!0):t<=-1&&await(0,exports.liquidatePosition)(i,e)};exports.checkForLiquidation=checkForLiquidation;const liquidatePosition=async(i,e,t=!1)=>{if(!(client&&scyllaFuturesKeyspace&&fromBigInt&&getWalletByUserIdAndCurrency&&updateWalletBalance))throw(0,error_1.createError)({statusCode:500,message:"Ecosystem extension not available"});const a=t?i.amount*BigInt(80)/BigInt(100):i.amount;await client.execute(`UPDATE ${scyllaFuturesKeyspace}.position SET amount = ?, status = ? WHERE "userId" = ? AND id = ?`,[t?a.toString():"0",t?"PARTIALLY_LIQUIDATED":"LIQUIDATED",i.userId,i.id],{prepare:!0});const n=await getWalletByUserIdAndCurrency(i.userId,i.symbol.split("/")[1]);if(n){const e=fromBigInt(a)*fromBigInt(i.entryPrice);await updateWalletBalance(n,e,"add")}await(0,ws_1.handlePositionBroadcast)(i);const o=await db_1.models.user.findOne({where:{id:i.userId}});o&&o.email&&(t?await sendPartialLiquidationNotificationEmail(o,i,e):await sendLiquidationNotificationEmail(o,i,e))};exports.liquidatePosition=liquidatePosition;const sendWarningEmail=async(i,e,t,a)=>{const n=await db_1.models.user.findOne({where:{id:i}});n&&n.email&&await sendLiquidationWarningEmail(n,e,t,a)};exports.sendWarningEmail=sendWarningEmail;