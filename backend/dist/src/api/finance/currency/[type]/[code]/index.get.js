"use strict";async function handleDeposit(e,r,t){switch(e){case"FIAT":return{gateways:await db_1.models.depositGateway.findAll({where:{status:!0,[sequelize_1.Op.and]:sequelize_1.Sequelize.literal(`JSON_CONTAINS(currencies, '"${r}"')`)}}),methods:await db_1.models.depositMethod.findAll({where:{status:!0}})};case"SPOT":{const e=await exchange_1.default.startExchange(t),i=await exchange_1.default.getProvider();if(!e)throw(0,error_1.createError)(500,"Exchange not found");const a=await e.fetchCurrencies();let n;if("xt"===i)n=Object.values(a).find(e=>e.code===r);else n=Object.values(a).find(e=>e.id===r);if(!n)throw(0,error_1.createError)(404,"Currency not found");if(!n.active)throw(0,error_1.createError)(400,"Withdrawal not enabled for this currency");switch(i){case"binance":case"kucoin":case"xt":if(!n.networks||"object"!=typeof n.networks||!Object.keys(n.networks).length)throw(0,error_1.createError)(400,"Networks data is missing or invalid");return Object.values(n.networks).filter(e=>e.active&&e.deposit).map(e=>({id:e.id,chain:e.network||e.name,fee:e.fee,precision:e.precision,limits:e.limits})).sort((e,r)=>e.chain.localeCompare(r.chain));case"kraken":return await e.fetchDepositMethods(r)}}break;case"ECO":return(await db_1.models.ecosystemToken.findAll({where:{status:!0,currency:r},attributes:["name","chain","icon","limits","fee","type","contractType"],order:[["chain","ASC"]]})).map(e=>{const r=e.get({plain:!0});let t={min:0,percentage:0},i={deposit:{min:1,max:1e6}};try{if(r.fee){t="string"==typeof r.fee?JSON.parse(r.fee):r.fee;t=t||{min:0,percentage:0}}}catch(e){console_1.logger.warn("CURRENCY",`Failed to parse fee for token ${r.name} (${r.chain})`,e);console_1.logger.warn("CURRENCY",`Raw fee value: ${JSON.stringify(r.fee)}`)}try{if(r.limits){i="string"==typeof r.limits?JSON.parse(r.limits):r.limits;i=i||{deposit:{min:1,max:1e6}}}}catch(e){console_1.logger.warn("CURRENCY",`Failed to parse limits for token ${r.name} (${r.chain})`,e);console_1.logger.warn("CURRENCY",`Raw limits value: ${JSON.stringify(r.limits)}`)}return{id:`${r.chain}_${r.type}`,chain:r.chain,network:r.chain,name:r.name,icon:r.icon,type:r.type,contractType:r.contractType,fee:t,limits:i,precision:8}});default:throw(0,error_1.createError)(400,"Invalid wallet type")}}async function handleWithdraw(e,r,t){switch(e){case"FIAT":return{methods:await db_1.models.withdrawMethod.findAll({where:{status:!0}})};case"SPOT":{const e=await exchange_1.default.startExchange(t),i=await exchange_1.default.getProvider();if(!e)throw(0,error_1.createError)(500,"Exchange not found");const a=await db_1.models.exchangeCurrency.findOne({where:{currency:r,status:!0}});if(!a)throw(0,error_1.createError)({statusCode:404,message:"Currency not found"});const n=a.fee||0,o=await e.fetchCurrencies();let s;if("xt"===i)s=Object.values(o).find(e=>e.code===r);else s=Object.values(o).find(e=>e.id===r);if(!s)throw(0,error_1.createError)(404,"Currency not found");if(!s.active)throw(0,error_1.createError)(400,"Withdrawal not enabled for this currency");if(!s.networks||"object"!=typeof s.networks||!Object.keys(s.networks).length)throw(0,error_1.createError)(400,"Networks data is missing or invalid");return Object.values(s.networks).filter(e=>e.active&&e.withdraw).map(e=>{var t,i,a,o,s;const c=e.network||e.name,d=e.fee||(null===(t=e.fees)||void 0===t?void 0:t.withdraw)||0,l=(null===(a=null===(i=e.limits)||void 0===i?void 0:i.withdraw)||void 0===a?void 0:a.min)||e.min_withdraw||0,u=(null===(s=null===(o=e.limits)||void 0===o?void 0:o.withdraw)||void 0===s?void 0:s.max)||e.max_withdraw||0;return{id:e.id,title:`${r} (${c})`,chain:c,network:c,fixedFee:d,percentageFee:n,minAmount:l,maxAmount:u,precision:e.precision,limits:e.limits,processingTime:"1-3",instructions:`Withdraw ${r} to your ${c} wallet address.`,customFields:JSON.stringify([{name:"address",title:`${c} Address`,type:"text",required:!0,placeholder:`Enter your ${c} wallet address`,validation:{pattern:"^[a-zA-Z0-9]{25,}$",message:"Invalid wallet address format"}}])}}).sort((e,r)=>e.chain.localeCompare(r.chain))}case"ECO":return(await db_1.models.ecosystemToken.findAll({where:{status:!0,currency:r},attributes:["name","chain","icon","limits","fee","type","contractType"],order:[["chain","ASC"]]})).map(e=>{var r,t,i,a;const n=e.get({plain:!0});let o={min:0,percentage:0},s={withdraw:{min:1,max:1e6}};try{if(n.fee){o="string"==typeof n.fee?JSON.parse(n.fee):n.fee;o=o||{min:0,percentage:0}}}catch(e){console_1.logger.warn("CURRENCY",`Failed to parse fee for token ${n.name}`,e)}try{if(n.limits){s="string"==typeof n.limits?JSON.parse(n.limits):n.limits;s=s||{withdraw:{min:1,max:1e6}}}}catch(e){console_1.logger.warn("CURRENCY",`Failed to parse limits for token ${n.name}`,e)}return{id:`${n.chain}_${n.type}`,title:`${n.name} (${n.chain})`,network:n.chain,chain:n.chain,type:n.type,contractType:n.contractType,image:n.icon,fixedFee:"number"==typeof o.min?o.min:parseFloat(o.min)||0,percentageFee:"number"==typeof o.percentage?o.percentage:parseFloat(o.percentage)||0,minAmount:"number"==typeof(null===(r=s.withdraw)||void 0===r?void 0:r.min)?s.withdraw.min:parseFloat(null===(t=s.withdraw)||void 0===t?void 0:t.min)||1,maxAmount:"number"==typeof(null===(i=s.withdraw)||void 0===i?void 0:i.max)?s.withdraw.max:parseFloat(null===(a=s.withdraw)||void 0===a?void 0:a.max)||1e6,processingTime:"1-3",instructions:`Withdraw ${n.name} to your ${n.chain} wallet address.`,customFields:JSON.stringify([{name:"address",title:`${n.chain} Address`,type:"text",required:!0,placeholder:`Enter your ${n.chain} wallet address`,validation:{pattern:"^[a-zA-Z0-9]{25,}$",message:"Invalid wallet address format"}}])}});default:throw(0,error_1.createError)(400,"Invalid wallet type")}}var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const exchange_1=__importDefault(require("@b/utils/exchange")),utils_1=require("../../utils"),query_1=require("@b/utils/query"),error_1=require("@b/utils/error"),db_1=require("@b/db"),sequelize_1=require("sequelize"),console_1=require("@b/utils/console");exports.metadata={summary:"Retrieves a single currency by its ID",description:"This endpoint retrieves a single currency by its ID.",operationId:"getCurrencyById",tags:["Finance","Currency"],requiresAuth:!0,parameters:[{name:"action",in:"query",description:"The action to perform",required:!1,schema:{type:"string"}},{index:0,name:"type",in:"path",required:!0,schema:{type:"string",enum:["FIAT","SPOT","ECO","FUTURES"]}},{index:1,name:"code",in:"path",required:!0,schema:{type:"string"}}],responses:{200:{description:"Currency retrieved successfully",content:{"application/json":{schema:{type:"object",properties:{...utils_1.baseResponseSchema,data:{type:"object",properties:utils_1.baseCurrencySchema}}}}}},401:query_1.unauthorizedResponse,404:(0,query_1.notFoundMetadataResponse)("Currency"),500:query_1.serverErrorResponse}};exports.default=async e=>{const{user:r,params:t,query:i,ctx:a}=e;if(!(null==r?void 0:r.id))throw(0,error_1.createError)(401,"Unauthorized");const{action:n}=i,{type:o,code:s}=t;if(!o||!s)throw(0,error_1.createError)(400,"Invalid type or code");switch(n){case"deposit":return handleDeposit(o,s,a);case"withdraw":return handleWithdraw(o,s,a);default:throw(0,error_1.createError)(400,"Invalid action")}};