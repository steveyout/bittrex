"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}});Object.defineProperty(e,a,i)}:function(e,t,r,a){void 0===a&&(a=r);e[a]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(){var e=function(t){e=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t};return e(t)};return function(t){if(t&&t.__esModule)return t;var r={};if(null!=t)for(var a=e(t),i=0;i<a.length;i++)"default"!==a[i]&&__createBinding(r,t,a[i]);__setModuleDefault(r,t);return r}}();Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const query_1=require("@b/utils/query"),utils_1=require("../utils"),db_1=require("@b/db"),cache_1=require("@b/utils/cache"),sequelize_1=require("sequelize"),console_1=require("@b/utils/console");exports.metadata={summary:"Retrieves detailed information of a specific user by UUID with extension data",operationId:"getUserByUuid",tags:["Admin","CRM","User"],parameters:[{index:0,name:"id",in:"path",required:!0,description:"ID of the user to retrieve",schema:{type:"string"}}],responses:{200:{description:"User details with extension data",content:{"application/json":{schema:{type:"object",properties:utils_1.userSchema}}}},401:query_1.unauthorizedResponse,404:(0,query_1.notFoundMetadataResponse)("User"),500:query_1.serverErrorResponse},requiresAuth:!0,permission:"view.user",demoMask:["email","phone"]};const getExtensionData=async(e,t)=>{var r,a,i,s,o,n;const d={};try{const l=await db_1.models.binaryOrder.findAll({where:{userId:e},attributes:["id","symbol","amount","profit","side","status","isDemo","createdAt"],limit:10,order:[["createdAt","DESC"]]}),u=await db_1.models.binaryOrder.findOne({where:{userId:e},attributes:[[(0,sequelize_1.fn)("COUNT",(0,sequelize_1.col)("id")),"totalTrades"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("CASE WHEN status = 'WIN' THEN 1 ELSE 0 END")),"winCount"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.literal)("CASE WHEN status = 'LOSS' THEN 1 ELSE 0 END")),"lossCount"],[(0,sequelize_1.fn)("SUM",(0,sequelize_1.col)("profit")),"totalProfit"]],raw:!0});d.binaryData={recentOrders:l,stats:u};const c=await db_1.models.exchangeOrder.findAll({where:{userId:e},attributes:["id","symbol","type","side","amount","price","filled","status","createdAt"],limit:10,order:[["createdAt","DESC"]]});d.spotData={recentOrders:c};if(t.has("forex")){const t=await db_1.models.transaction.findAll({where:{userId:e,type:{[sequelize_1.Op.in]:["FOREX_DEPOSIT","FOREX_WITHDRAW"]}},include:[{model:db_1.models.wallet,as:"wallet",attributes:["currency","type"]}],attributes:["id","type","amount","status","description","createdAt"],limit:20,order:[["createdAt","DESC"]]}),a=await(null===(r=db_1.models.forexInvestment)||void 0===r?void 0:r.findAll({where:{userId:e},include:[{model:db_1.models.forexPlan,as:"plan",attributes:["name","title","currency","walletType"]},{model:db_1.models.forexDuration,as:"duration",attributes:["duration","timeframe"]}],attributes:["id","amount","profit","result","status","endDate","createdAt"],limit:10,order:[["createdAt","DESC"]]}))||[],i=t.filter(e=>"FOREX_DEPOSIT"===e.type),s=t.filter(e=>"FOREX_WITHDRAW"===e.type);d.forexData={deposits:i,withdrawals:s,investments:a}}if(t.has("futures"))try{const t="@b/api/(ext)/ecosystem/utils/scylla/queries",{query:r}=await Promise.resolve(`${t}`).then(e=>__importStar(require(e))),a=process.env.SCYLLA_FUTURES_KEYSPACE||"futures",i=await r(`SELECT * FROM ${a}.orders WHERE "userId" = ? ORDER BY "createdAt" DESC LIMIT 10`,[e]),s=await r(`SELECT * FROM ${a}.position WHERE "userId" = ? LIMIT 10`,[e]);d.futuresData={recentOrders:i.rows||[],positions:s.rows||[]}}catch(e){console_1.logger.warn("FUTURES",`Failed to fetch futures data from ScyllaDB: ${e.message}`);d.futuresData={recentOrders:[],positions:[]}}if(t.has("ecosystem"))try{const t="@b/api/(ext)/ecosystem/utils/scylla/queries",{query:r}=await Promise.resolve(`${t}`).then(e=>__importStar(require(e))),a=process.env.SCYLLA_KEYSPACE||"trading",i=await r(`SELECT * FROM ${a}.orders WHERE "userId" = ? ORDER BY "createdAt" DESC LIMIT 10`,[e]);d.ecosystemData={recentOrders:i.rows||[]}}catch(e){console_1.logger.warn("ECOSYSTEM",`Failed to fetch ecosystem data from ScyllaDB: ${e.message}`);d.ecosystemData={recentOrders:[]}}if(t.has("ai_investment")){const t=await(null===(a=db_1.models.aiInvestment)||void 0===a?void 0:a.findAll({where:{userId:e},include:[{model:db_1.models.aiInvestmentPlan,as:"plan",attributes:["name","title"]},{model:db_1.models.aiInvestmentDuration,as:"duration",attributes:["duration","timeframe"]}],attributes:["id","amount","profit","result","status","createdAt"],limit:10,order:[["createdAt","DESC"]]}))||[];d.aiData={investments:t}}if(t.has("ico")){const t=await(null===(i=db_1.models.icoTransaction)||void 0===i?void 0:i.findAll({where:{userId:e},include:[{model:db_1.models.icoTokenOffering,as:"offering",attributes:["name","symbol","status"]}],attributes:["id","amount","price","status","createdAt"],limit:10,order:[["createdAt","DESC"]]}))||[];d.icoData={contributions:t}}if(t.has("p2p")){const t=await(null===(s=db_1.models.p2pOffer)||void 0===s?void 0:s.findAll({where:{userId:e},attributes:["id","type","currency","status","views","createdAt"],limit:10,order:[["createdAt","DESC"]]}))||[],r=await(null===(o=db_1.models.p2pTrade)||void 0===o?void 0:o.findAll({where:{[sequelize_1.Op.or]:[{sellerId:e},{buyerId:e}]},attributes:["id","amount","price","status","createdAt"],limit:10,order:[["createdAt","DESC"]]}))||[];d.p2pData={offers:t,trades:r}}if(t.has("staking")){const t=await(null===(n=db_1.models.stakingPosition)||void 0===n?void 0:n.findAll({where:{userId:e},include:[{model:db_1.models.stakingPool,as:"pool",attributes:["name","symbol","apr"]}],attributes:["id","amount","status","startDate","endDate","createdAt"],limit:10,order:[["createdAt","DESC"]]}))||[];d.stakingData={logs:t}}}catch(e){console_1.logger.error("USER","Error fetching extension data",e)}return d};exports.default=async e=>{const{params:t}=e,r=cache_1.CacheManager.getInstance(),a=await r.getExtensions(),i=await(0,query_1.getRecord)("user",t.id,[{model:db_1.models.role,as:"role",attributes:["id","name"]},{model:db_1.models.kycApplication,as:"kyc",required:!1,attributes:["id","status","reviewedAt","createdAt","data","adminNotes"]},{model:db_1.models.twoFactor,as:"twoFactor",required:!1,attributes:["id","enabled","type","createdAt"]},{model:db_1.models.notification,as:"notifications",required:!1,attributes:["id","type","title","message","read","createdAt"]}],["password","metadata"]);if(i){const e="function"==typeof i.get?i.get({plain:!0}):i,t=await getExtensionData(e.id,a);Object.assign(e,t);return e}return null};