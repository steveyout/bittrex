"use strict";async function verifyWithGemini(e,t){var i;try{const r=process.env.GEMINI_API_KEY;if(!r)throw new Error("Gemini API key not configured");let s=e.submittedData||e.data;if(!s)throw new Error("No submitted data found in application");"string"==typeof s&&(s=JSON.parse(s));const n="string"==typeof t.fields?JSON.parse(t.fields):t.fields,o=processLevelFields(n,s);if(0===Object.keys(o.documents).length)throw new Error("No documents found for verification");const{GoogleGenerativeAI:a}=await Promise.resolve().then(()=>__importStar(require("@google/generative-ai"))),c=new a(r).getGenerativeModel({model:"gemini-1.5-pro"}),l=[],u=createDynamicVerificationPrompt(o);l.push(u);for(const[e,t]of Object.entries(o.documents))try{const i=findFieldById(n,e.split("-")[0]),r=i?i.label:e;if(String(t).startsWith("http"))l.push({fileData:{fileUri:String(t),mimeType:"image/jpeg"}});else{const e=await convertImageToBase64(String(t));l.push({inlineData:{data:e,mimeType:"image/jpeg"}})}l.push(`This is the ${r}.`)}catch(t){console_1.logger.warn("KYC",`Failed to process document ${e}: ${t}`)}const d=await c.generateContent(l,{responseFormat:{type:"json_object"}}),p=cleanJSONOutput(d.response.text());let f=null;try{f=JSON.parse(p)}catch(e){console_1.logger.warn("KYC","Failed to parse Gemini response as JSON, falling back to basic analysis")}const m=f||analyzeAIResponse(p),h=!0===m.selfieMatch&&!0===m.documentAuthentic?"VERIFIED":"FAILED",y=null!==(i=m.confidenceScore)&&void 0!==i?i:.6;return{status:h,score:y<=1?100*y:y,checks:m,documentVerifications:{message:"Gemini verification completed",details:"Document verification has been completed by Gemini AI.",aiResponse:m.summary?m.summary:p}}}catch(e){console_1.logger.error("KYC","Gemini verification error",e);let t="An error occurred during Gemini verification";const i=e.message||"";400===e.status?t="Invalid request format":401===e.status?t="Authentication failed - invalid API key":402===e.status?t="Insufficient balance in Gemini account":422===e.status?t="Invalid parameters in request":429===e.status?t="Rate limit reached - too many requests":500===e.status?t="Gemini server error":503===e.status&&(t="Gemini server overloaded");return{status:"FAILED",score:null,checks:{message:"Gemini verification failed",details:t,error:i},documentVerifications:null}}}function cleanJSONOutput(e){return e.replace(/```(json)?/g,"").trim()}async function convertImageToBase64(e){if(e.startsWith("data:image"))return e.split(",")[1];if(!e.startsWith("http")){const t=path_1.default.join(process.cwd(),"..","frontend","public"),i=path_1.default.join(t,e);try{return(await promises_1.default.readFile(i)).toString("base64")}catch(e){console_1.logger.error("KYC","Error reading local file",e);throw new Error("Failed to process local image for verification")}}try{const t=await fetch(e),i=await t.arrayBuffer();return Buffer.from(i).toString("base64")}catch(e){console_1.logger.error("KYC","Error converting image to base64",e);throw new Error("Failed to process image for verification")}}function processLevelFields(e,t){const i={textFields:{},documents:{},personalInfo:{},addresses:[],hasSelfie:!1};processFields(e,t,i);return i}function processFields(e,t,i,r=""){e.forEach(e=>{const s=e.id,n=t[s];if(null==n)return;const o=e.type,a=e.label?e.label.toLowerCase():"";if("FILE"===o||"IMAGE"===o){i.documents[s]=n;a.includes("selfie")&&(i.hasSelfie=!0)}else if("IDENTITY"===o){if("object"==typeof n)for(const e in n)if("type"!==e&&"string"==typeof n[e]&&""!==n[e].trim()){const t=`${s}-${e}`;i.documents[t]=n[e];e.toLowerCase().includes("selfie")&&(i.hasSelfie=!0)}}else if("SECTION"===o||"SUBSECTION"===o)e.fields&&Array.isArray(e.fields)&&processFields(e.fields,t,i,`${r}${s}.`);else{i.textFields[s]={value:n,label:e.label,type:o};"TEXT"===o?a.includes("first name")?i.personalInfo.firstName=n:a.includes("last name")?i.personalInfo.lastName=n:a.includes("nationality")&&(i.personalInfo.nationality=n):"EMAIL"===o?i.personalInfo.email=n:"PHONE"===o?i.personalInfo.phone=n:"DATE"===o&&a.includes("birth")?i.personalInfo.dob=n:"SELECT"===o&&a.includes("country")?i.personalInfo.country=n:"ADDRESS"===o&&"object"==typeof n&&i.addresses.push({country:n.country,postCode:n.postalCode,town:n.city,street:n.street,subStreet:n.apartment,state:n.state})}})}function findFieldById(e,t,i=""){for(const r of e){if(r.id===t)return r;if(("SECTION"===r.type||"SUBSECTION"===r.type)&&r.fields&&Array.isArray(r.fields)){const e=findFieldById(r.fields,t,`${i}${r.id}.`);if(e)return e}}return null}function createDynamicVerificationPrompt(e){return`\nPlease verify the following ID document(s) for authenticity and confirm whether the provided personal information matches the document. Use the data below to assess both the document and the selfie (if provided).\n\nUser Information:\n${JSON.stringify(e.personalInfo,null,2)}\n\nDocument Data:\n${JSON.stringify(e.documents,null,2)}\n\nVerification Tasks:\n1. Check if the document appears authentic.\n2. Verify that the user information matches what is on the document.\n3. If a selfie is provided, determine whether the selfie image matches the photo on the document.\n4. Provide a human-readable summary of the verification outcome.\n\nPlease output your answer as a raw JSON object (without any markdown or code block formatting) with exactly the following keys:\n{\n  "summary": string,\n  "selfieMatch": boolean,\n  "documentAuthentic": boolean,\n  "confidenceScore": number,\n  "issues": string[],\n  "extractedInfo": {}\n}\n`}function analyzeAIResponse(e){const t=e.toLowerCase(),i=!(t.includes("fake")||t.includes("tampered")||t.includes("manipulated")||t.includes("fail"));let r=60;const s=e.match(/confidence(?:\s+score)?(?:\s+of)?(?:\s+is)?[:\s]+(\d+)%?/i);r=s&&s[1]?Number.parseInt(s[1],10):t.includes("high confidence")?90:t.includes("medium confidence")?70:t.includes("low confidence")?40:60;const n=[];t.includes("mismatch")&&n.push("Information mismatch");t.includes("blur")&&n.push("Blurry image");t.includes("expired")&&n.push("Expired document");t.includes("damaged")&&n.push("Damaged document");t.includes("photoshop")&&n.push("Signs of manipulation");t.includes("selfie")&&t.includes("match")&&t.includes("not")&&n.push("Selfie does not match ID photo");const o=e.split("\n\n")[0]||e.split(".")[0]+".",a={},c=e.match(/name(?:\s+is)?[:\s]+([A-Za-z\s]+)/i);c&&c[1]&&(a.name=c[1].trim());const l=e.match(/(?:date of birth|dob|born)(?:\s+is)?[:\s]+([A-Za-z0-9\s,./-]+)/i);l&&l[1]&&(a.dateOfBirth=l[1].trim());const u=e.match(/(?:document|id|passport)(?:\s+number)(?:\s+is)?[:\s]+([A-Za-z0-9\s]+)/i);u&&u[1]&&(a.documentNumber=u[1].trim());return{summary:o,selfieMatch:t.includes("selfie match")&&!t.includes("not"),documentAuthentic:i,confidenceScore:r,issues:n,extractedInfo:a}}async function verifyWithSumSub(e,t){try{const i=process.env.SUMSUB_API_KEY,r=process.env.SUMSUB_API_SECRET;if(!i||!r)throw new Error("SumSub API credentials not configured");const{userId:s,submittedData:n}=e;if(!n)throw new Error("No submitted data found in application");const o=processLevelFields(t.fields,n),a=Math.floor(Date.now()/1e3).toString(),c=JSON.stringify({externalUserId:s,info:{...o.personalInfo,addresses:o.addresses.length>0?o.addresses:void 0},requiredIdDocs:{docSets:[{idDocSetType:"IDENTITY",types:["PASSPORT","ID_CARD","DRIVERS"],subTypes:["FRONT_SIDE","BACK_SIDE"]},...o.hasSelfie?[{idDocSetType:"SELFIE",types:["SELFIE"],subTypes:[]}]:[]]}}),l=crypto_1.default.createHmac("sha256",r).update(a+c).digest("hex"),u=await fetch("https://api.sumsub.com/resources/applicants",{method:"POST",headers:{"X-App-Token":i,"X-App-Access-Sig":l,"X-App-Access-Ts":a,"Content-Type":"application/json"},body:c});if(!u.ok){const e=await u.json();throw new Error(`SumSub API error: ${e.description||u.statusText}`)}const d=await u.json();return{status:"PENDING",score:null,checks:{message:"SumSub verification initiated",details:"Your application has been sent to SumSub for verification.",applicantId:d.id,reviewStatus:d.reviewStatus,externalUserId:d.externalUserId,processedFields:Object.keys(n).length},documentVerifications:{message:"SumSub verification completed",details:"No further document analysis available for SumSub."}}}catch(e){console_1.logger.error("KYC","SumSub verification error",e);return{status:"FAILED",score:null,checks:{message:"SumSub verification failed",details:e.message||"An error occurred during SumSub verification",error:e.toString()},documentVerifications:null}}}var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,i,r){void 0===r&&(r=i);var s=Object.getOwnPropertyDescriptor(t,i);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[i]}});Object.defineProperty(e,r,s)}:function(e,t,i,r){void 0===r&&(r=i);e[r]=t[i]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(){var e=function(t){e=Object.getOwnPropertyNames||function(e){var t=[];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[t.length]=i);return t};return e(t)};return function(t){if(t&&t.__esModule)return t;var i={};if(null!=t)for(var r=e(t),s=0;s<r.length;s++)"default"!==r[s]&&__createBinding(i,t,r[s]);__setModuleDefault(i,t);return i}}(),__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const db_1=require("@b/db"),error_1=require("@b/utils/error"),crypto_1=__importDefault(require("crypto")),promises_1=__importDefault(require("fs/promises")),path_1=__importDefault(require("path")),redis_1=require("@b/utils/redis"),console_1=require("@b/utils/console");exports.metadata={summary:"Verify KYC Application",description:"Submits a KYC application for verification using the specified verification service.",operationId:"verifyKycApplication",tags:["KYC","Verification Services","Applications"],logModule:"ADMIN_CRM",logTitle:"Verify KYC application",parameters:[{index:0,name:"id",in:"path",description:"Verification service ID",required:!0,schema:{type:"string"}}],requestBody:{required:!0,content:{"application/json":{schema:{type:"object",properties:{applicationId:{type:"string",description:"ID of the KYC application to verify"}},required:["applicationId"]}}}},responses:{200:{description:"Verification process initiated successfully.",content:{"application/json":{schema:{type:"object",properties:{id:{type:"string",description:"Verification result ID"},applicationId:{type:"string",description:"KYC application ID"},serviceId:{type:"string",description:"Verification service ID"},serviceName:{type:"string",description:"Verification service name"},status:{type:"string",enum:["VERIFIED","FAILED","PENDING","NOT_STARTED"],description:"Verification status"},score:{type:"number",description:"Verification confidence score (percentage)",nullable:!0},checks:{type:"object",description:"Structured verification checks (JSON object with keys such as summary, selfieMatch, documentAuthentic, confidenceScore, issues, and extractedInfo)",nullable:!0},documentVerifications:{type:"object",description:"Document verification details including a humanâ€readable summary (aiResponse)",nullable:!0},createdAt:{type:"string",format:"date-time",description:"When the verification was initiated"}}}}}},400:{description:"Missing required fields."},404:{description:"Verification service or application not found."},500:{description:"Internal Server Error."}},permission:"edit.kyc.verification",requiresAuth:!0};exports.default=async e=>{const{params:t,body:i,ctx:r}=e;try{const{id:e}=t,{applicationId:s}=i;if(!s)throw(0,error_1.createError)({statusCode:400,message:"Missing required field: applicationId"});null==r||r.step(`Fetching KYC application ${s}`);const n=await db_1.models.kycApplication.findByPk(s,{include:[{model:db_1.models.kycLevel,as:"level",paranoid:!1,include:[{model:db_1.models.kycVerificationService,as:"verificationService"}]}]});if(!n)throw(0,error_1.createError)({statusCode:404,message:"KYC application not found"});const o=n.level;if(!o)throw(0,error_1.createError)({statusCode:404,message:"KYC level not found for this application"});const a=o.verificationService;if(!a)throw(0,error_1.createError)({statusCode:404,message:"Verification service not found in KYC level configuration"});null==r||r.step(`Initiating verification with ${a.type}`);let c;if("SUMSUB"===a.type)c=await verifyWithSumSub(n,o);else{if("GEMINI"!==a.type)throw(0,error_1.createError)({statusCode:400,message:`Unsupported verification service type: ${a.type}`});c=await verifyWithGemini(n,o)}null==r||r.step("Saving verification result");const l=await db_1.models.kycVerificationResult.create({applicationId:s,serviceId:a.id,status:c.status,score:c.score,checks:c.checks,documentVerifications:c.documentVerifications,createdAt:new Date}),u="PENDING"===c.status?"PENDING":"VERIFIED"===c.status?"APPROVED":"FAILED"===c.status?"REJECTED":"PENDING";null==r||r.step(`Updating application status to ${u}`);await n.update({status:u,updatedAt:new Date,reviewedAt:new Date});if("APPROVED"===u)try{const e=redis_1.RedisSingleton.getInstance();await e.del(`user:${n.userId}:profile`)}catch(e){console_1.logger.error("KYC","Error clearing user cache after KYC approval",e)}null==r||r.success(`Verification completed with status: ${c.status}`);return{id:l.id,applicationId:s,serviceId:a.id,serviceName:a.name,status:c.status,score:c.score,checks:c.checks,documentVerifications:c.documentVerifications,createdAt:l.createdAt}}catch(e){console_1.logger.error("KYC","Error in verifyKycApplication",e);e.response&&console_1.logger.error("KYC",`API Response Error: status=${e.response.status}, data=${JSON.stringify(e.response.data)}`);throw(0,error_1.createError)({statusCode:e.statusCode||500,message:e.message||"Failed to initiate verification process"})}};