"use strict";function parseMetadata(e){let t={};try{e=e.replace(/\\/g,"");t=JSON.parse(e)||{}}catch(e){console_1.logger.error("DEPOSIT","Invalid JSON in metadata",e)}return t}async function handleWalletRejection(){}async function handleWalletCompletion(e,t,a){const s=Number(e.amount)-Number(e.fee);if(s>0){const n=`admin_deposit_approve_${e.id}`;await wallet_1.walletService.credit({idempotencyKey:n,userId:e.userId,walletId:t.id,walletType:t.type,currency:t.currency,amount:s,operationType:"DEPOSIT",referenceId:e.id,description:`Deposit approved - ${s} ${t.currency}`,metadata:{transactionId:e.id,fee:e.fee},transaction:a})}}Object.defineProperty(exports,"__esModule",{value:!0});exports.metadata=void 0;const query_1=require("@b/utils/query"),db_1=require("@b/db"),utils_1=require("../utils"),emails_1=require("@b/utils/emails"),console_1=require("@b/utils/console"),wallet_1=require("@b/services/wallet"),error_1=require("@b/utils/error");exports.metadata={summary:"Updates an existing deposit transaction",operationId:"updateDepositTransaction",tags:["Admin","Finance","Deposits"],parameters:[{index:0,name:"id",in:"path",description:"The ID of the deposit transaction to update",required:!0,schema:{type:"string"}}],requestBody:{required:!0,description:"Updated data for the deposit transaction",content:{"application/json":{schema:utils_1.depositUpdateSchema}}},responses:(0,query_1.updateRecordResponses)("Deposit Transaction"),requiresAuth:!0,permission:"edit.deposit",logModule:"ADMIN_FIN",logTitle:"Update deposit transaction"};exports.default=async e=>{const{body:t,params:a,ctx:s}=e,{id:n}=a,{status:r,amount:i,fee:o,description:d,referenceId:c,metadata:l}=t;null==s||s.step("Fetching deposit transaction");const u=await db_1.models.transaction.findOne({where:{id:n}});if(!u)throw(0,error_1.createError)({statusCode:404,message:"Transaction not found"});if("PENDING"!==u.status)throw(0,error_1.createError)({statusCode:400,message:"Only pending transactions can be updated"});u.amount=i;u.fee=o;u.description=d;u.referenceId=c;return await db_1.sequelize.transaction(async e=>{const t=parseMetadata(u.metadata);null==s||s.step("Fetching wallet");const a=await db_1.models.wallet.findOne({where:{id:u.walletId},transaction:e});if(!a)throw(0,error_1.createError)({statusCode:404,message:"Wallet not found"});if("PENDING"===u.status){if("REJECTED"===r){null==s||s.step("Processing transaction rejection");await handleWalletRejection(a,e)}else if("COMPLETED"===r){null==s||s.step("Processing transaction completion");await handleWalletCompletion(u,a,e)}null==s||s.step("Sending status update email");const n=await db_1.models.user.findOne({where:{id:u.userId}});n&&await(0,emails_1.sendTransactionStatusUpdateEmail)(n,u,a,a.balance,t.message||null)}l&&(t.message=l.message);u.metadata=JSON.stringify(t);u.status=r;null==s||s.step("Saving transaction");await u.save({transaction:e});null==s||s.success("Deposit transaction updated successfully");return{message:"Transaction updated successfully"}})};