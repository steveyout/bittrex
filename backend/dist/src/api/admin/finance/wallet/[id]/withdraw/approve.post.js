"use strict";async function getWalletQuery(e,r){const a=await db_1.models.wallet.findOne({where:{userId:e,currency:r,type:"SPOT"},include:[{model:db_1.models.transaction,as:"transactions",order:[["createdAt","DESC"]]}]});if(!a)throw(0,error_1.createError)(404,"Wallet not found");return a.get({plain:!0})}async function getCurrency(e){const r=await db_1.models.exchangeCurrency.findOne({where:{currency:e}});if(!r)throw(0,error_1.createError)({statusCode:404,message:"Currency details not found"});return r.get({plain:!0})}function mapChainNameToChainId(e){return{BEP20:"bsc",BEP2:"bnb",ERC20:"eth",TRC20:"trx"}[e]||e}var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});exports.getUserById=exports.metadata=void 0;exports.getWalletQuery=getWalletQuery;exports.getCurrency=getCurrency;exports.mapChainNameToChainId=mapChainNameToChainId;const utils_1=require("@b/api/auth/utils"),emails_1=require("@b/utils/emails"),error_1=require("@b/utils/error"),exchange_1=__importDefault(require("@b/utils/exchange")),db_1=require("@b/db"),query_1=require("@b/utils/query"),console_1=require("@b/utils/console");exports.metadata={summary:"Approves a spot wallet withdrawal request",operationId:"approveSpotWalletWithdrawal",tags:["Admin","Wallets"],parameters:[{name:"id",in:"path",required:!0,description:"The ID of the wallet withdrawal to approve",schema:{type:"string",format:"uuid"}}],responses:{200:{description:"Withdrawal request approved successfully",content:{"application/json":{schema:{type:"object",properties:{message:{type:"string"}}}}}},401:query_1.unauthorizedResponse,404:(0,query_1.notFoundMetadataResponse)("Wallet"),500:query_1.serverErrorResponse},permission:"edit.wallet",requiresAuth:!0,logModule:"ADMIN_FIN",logTitle:"Approve Withdrawal"};exports.default=async e=>{var r,a,t;const{params:s,ctx:o}=e,{id:i}=s;try{null==o||o.step("Fetching transaction");const e=await db_1.models.transaction.findOne({where:{id:i}});if(!e)throw(0,error_1.createError)({statusCode:404,message:"Transaction not found"});if("PENDING"!==e.status)throw(0,error_1.createError)({statusCode:400,message:"Transaction is not pending"});const{amount:s,userId:n}=e,{currency:l,chain:d,address:c,memo:u}=e.metadata;null==o||o.step("Fetching wallet and currency data");const h=await getWalletQuery(n,l);if(!h)throw(0,error_1.createError)({statusCode:404,message:"Wallet not found"});const f=await getCurrency(l);if(!f)throw(0,error_1.createError)({statusCode:404,message:"Currency not found"});const m=(null===(a=null===(r=f.chains)||void 0===r?void 0:r.find(e=>e.network===d))||void 0===a?void 0:a.withdrawFee)||0,p=Number(s)+Number(m);if(p>h.balance)throw(0,error_1.createError)({statusCode:400,message:"Your withdraw amount including fee is higher than your balance"});null==o||o.step("Initializing exchange");const w=await exchange_1.default.startExchange(),g=await exchange_1.default.provider;null==o||o.step("Processing withdrawal");let _,y;switch(g){case"kucoin":try{const e=mapChainNameToChainId(d);if((await w.transfer(l,p,"main","trade")).id)try{_=await w.withdraw(l,p,c,u,{chain:e});if(_.id)try{const e=(await w.fetchWithdrawals(l)).find(e=>e.id===_.id);if(e){_.fee=p*m+(null===(t=e.fee)||void 0===t?void 0:t.cost);switch(e.status){case"completed":case"ok":y="COMPLETED";break;case"cancelled":case"canceled":y="CANCELLED";break;case"failed":y="FAILED";break;default:y="PENDING"}}}catch(e){_.fee=m}}catch(e){console_1.logger.error("WALLET",`Withdrawal failed: ${e.message}`,e);throw(0,error_1.createError)({statusCode:500,message:`Withdrawal failed: ${e.message}`})}}catch(e){console_1.logger.error("WALLET",`Transfer failed: ${e.message}`,e);throw(0,error_1.createError)({statusCode:500,message:`Transfer failed: ${e.message}`})}break;case"binance":case"okx":try{_=await w.withdraw(l,p,c,u,{network:d});_.fee=Number(_.fee)||m;switch(_.status){case"completed":case"ok":y="COMPLETED";break;case"canceled":y="CANCELLED";break;case"failed":y="FAILED";break;default:y="PENDING"}}catch(e){console_1.logger.error("WALLET",`Withdrawal failed: ${e.message}`,e);throw(0,error_1.createError)({statusCode:500,message:`Withdrawal failed: ${e.message}`})}}if(!_||!_.id||!y||"FAILED"===y||"CANCELLED"===y)throw(0,error_1.createError)({statusCode:500,message:"Withdrawal failed"});null==o||o.step("Updating transaction status");await db_1.models.transaction.update({status:y,referenceId:_.id},{where:{id:i}});const E=await db_1.models.transaction.findOne({where:{id:i}});if(!E)throw(0,error_1.createError)(500,"Transaction not found");try{null==o||o.step("Sending confirmation email");const e=await(0,exports.getUserById)(n,o);(0,emails_1.sendSpotWalletWithdrawalConfirmationEmail)(e,E.get({plain:!0}),h)}catch(e){console_1.logger.error("WALLET",`Withdrawal confirmation email failed: ${e.message}`,e)}null==o||o.success("Withdrawal approved successfully");return{message:"Withdrawal approved successfully"}}catch(e){throw(0,error_1.createError)({statusCode:500,message:e.message})}};const getUserById=async(e,r)=>{var a,t,s;null===(a=null==r?void 0:r.step)||void 0===a||a.call(r,"Fetching user by ID");const o=await db_1.models.user.findOne({where:{id:e},include:utils_1.userInclude});if(!o){null===(t=null==r?void 0:r.fail)||void 0===t||t.call(r,"User not found");throw(0,error_1.createError)({statusCode:404,message:"User not found"})}null===(s=null==r?void 0:r.success)||void 0===s||s.call(r,"User fetched successfully");return{...o.get({plain:!0}),password:void 0}};exports.getUserById=getUserById;