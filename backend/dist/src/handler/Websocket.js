"use strict";async function setupWebSocketEndpoint(e,r,t){let s,o,a;const i=Routes_1.routeCache.get(t);if(i&&i.metadata)({handler:s,metadata:o,onClose:a}=i);else{const e=await Promise.resolve(`${t}`).then(e=>__importStar(require(e)));s=e.default;if(!s)throw(0,error_1.createError)({statusCode:404,message:`Handler not found for ${t}`});o=e.metadata;if(!o)throw(0,error_1.createError)({statusCode:404,message:`Metadata not found for ${t}`});a=e.onClose;Routes_1.routeCache.set(t,{handler:s,metadata:o,onClose:a})}if("function"!=typeof s)throw(0,error_1.createError)({statusCode:500,message:`Handler is not a function for ${t}`});e.ws(r,{pong:e=>{e.isAlive=!0},upgrade:async(s,a,i)=>{const n=new Response_1.Response(s),c=new Request_1.Request(s,a);c.params=(0,ws_1.parseParams)(r,c.url);try{if(!o)throw(0,error_1.createError)({statusCode:404,message:`Metadata not found for ${t}`});c.setMetadata(o)}catch(e){console_1.logger.error("WS",`Error setting metadata for ${t}`,e);n.cork(async()=>{n.handleError(500,"Internal Server Error")});return}try{o.requiresAuth?await(0,Middleware_1.rateLimit)(n,c,async()=>{await(0,Middleware_1.authenticate)(n,c,async()=>{await(0,Middleware_1.rolesGate)(e,n,c,r,"ws",async()=>{n.cork(async()=>{const e=c.url.split("?")[0];n.upgrade({user:c.user,params:c.params,query:c.query,path:e},c.headers["sec-websocket-key"],c.headers["sec-websocket-protocol"],c.headers["sec-websocket-extensions"],i)})})})}):n.cork(async()=>{var e,r;const t=c.url.split("?")[0];n.upgrade({user:{id:(null===(e=c.query)||void 0===e?void 0:e.userId)||(0,passwords_1.makeUuid)(),role:(null===(r=c.query)||void 0===r?void 0:r.userId)?"user":"guest"},params:c.params,query:c.query,path:t},c.headers["sec-websocket-key"],c.headers["sec-websocket-protocol"],c.headers["sec-websocket-extensions"],i)})}catch(e){console_1.logger.error("WS",`Error upgrading connection for ${t}`,e);n.cork(async()=>{n.close()})}},open:e=>{e.isAlive=!0;e.isClosed=!1;if(!e.user||void 0===e.user.id){console_1.logger.error("WS","User or user ID is undefined");return}const r=e.user.id;(0,exports.registerClient)(e.path,r,e)},message:async(e,r,o)=>{const a=Buffer.from(r).toString("utf-8");try{const r=JSON.parse(a);"SUBSCRIBE"!==r.action&&"UNSUBSCRIBE"!==r.action||processSubscriptionChange(e,r);const t=await s(e,r,o);if(t)try{e.send(JSON.stringify(t))}catch(e){console_1.logger.error("WS","Failed to send response",e)}}catch(e){console_1.logger.error("WS",`Failed to parse/handle message for ${t}`,e)}},close:async e=>{"function"==typeof a&&await a(e,e.path,e.user.id);e.isClosed=!0;(0,exports.deregisterClient)(e.path,e.user.id)}})}function processSubscriptionChange(e,r){if(!r.payload)throw(0,error_1.createError)({statusCode:400,message:"Invalid subscription payload"});const t=e.user.id,s=e.path,o=JSON.stringify(r.payload);"SUBSCRIBE"===r.action?(0,exports.registerClient)(s,t,e,o):"UNSUBSCRIBE"===r.action&&(0,exports.removeClientSubscription)(s,t,o)}async function processWebSocketMessage(e){let r;const{type:t,model:s,id:o,data:a,method:i,status:n,sendMessage:c}=e;if("update"===i){if(!o)throw(0,error_1.createError)({statusCode:400,message:"ID is required for update method"});if(!0===n){if(!s)throw(0,error_1.createError)({statusCode:400,message:"Model is required for update method"});if(Array.isArray(o)){const e=await(0,query_1.getRecords)(s,o);if(!e||0===e.length)throw(0,error_1.createError)({statusCode:404,message:`Records with IDs ${o.join(", ")} not found`});r=e}else{const e=await(0,query_1.getRecord)(s,o);if(!e)throw(0,error_1.createError)({statusCode:404,message:`Record with ID ${o} not found`});r=e}c("create",r)}else if(!1===n)c("delete",Array.isArray(o)?o.map(e=>({id:e})):{id:o});else{r={id:o,data:a};c("update",r)}}else if("create"===i){if(a)r=a;else{if(!s||!o)throw(0,error_1.createError)({statusCode:400,message:"Model and ID are required for create method when no data is provided"});if(Array.isArray(o)){const e=await(0,query_1.getRecords)(s,o);if(!e||0===e.length)throw(0,error_1.createError)({statusCode:404,message:`Records with IDs ${o.join(", ")} not found`});r=e}else{const e=await(0,query_1.getRecord)(s,o);if(!e)throw(0,error_1.createError)({statusCode:404,message:`Record with ID ${o} not found`});r=e}}c("create",r)}else if("delete"===i){if(!o)throw(0,error_1.createError)({statusCode:400,message:"ID is required for delete method"});c("delete",Array.isArray(o)?o.map(e=>({id:e})):{id:o})}}var __createBinding=this&&this.__createBinding||(Object.create?function(e,r,t,s){void 0===s&&(s=t);var o=Object.getOwnPropertyDescriptor(r,t);o&&!("get"in o?!r.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return r[t]}});Object.defineProperty(e,s,o)}:function(e,r,t,s){void 0===s&&(s=t);e[s]=r[t]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),__importStar=this&&this.__importStar||function(){var e=function(r){e=Object.getOwnPropertyNames||function(e){var r=[];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[r.length]=t);return r};return e(r)};return function(r){if(r&&r.__esModule)return r;var t={};if(null!=r)for(var s=e(r),o=0;o<s.length;o++)"default"!==s[o]&&__createBinding(t,r,s[o]);__setModuleDefault(t,r);return t}}();Object.defineProperty(exports,"__esModule",{value:!0});exports.hasClients=exports.handleDirectClientMessage=exports.handleBroadcastMessage=exports.removeClientSubscription=exports.deregisterClient=exports.registerClient=exports.messageBroker=exports.clients=void 0;exports.setupWebSocketEndpoint=setupWebSocketEndpoint;const ws_1=require("@b/utils/ws"),Middleware_1=require("./Middleware"),Request_1=require("./Request"),Response_1=require("./Response"),passwords_1=require("@b/utils/passwords"),query_1=require("@b/utils/query"),console_1=require("@b/utils/console"),error_1=require("@b/utils/error"),Routes_1=require("./Routes"),heartbeat_1=require("./ws/heartbeat"),messageBroker_1=require("./ws/messageBroker");exports.clients=new Map;exports.messageBroker=new messageBroker_1.MessageBroker(exports.clients);const registerClient=(e,r,t,s)=>{if(!e||!r||!t)return;exports.clients.has(e)||exports.clients.set(e,new Map);const o=exports.clients.get(e);o.has(r)?s&&o.get(r).subscriptions.add(s):o.set(r,{ws:t,subscriptions:new Set(s?[s]:[])})};exports.registerClient=registerClient;const deregisterClient=(e,r)=>{if(exports.clients.has(e)){const t=exports.clients.get(e);t.delete(r);0===t.size&&exports.clients.delete(e)}};exports.deregisterClient=deregisterClient;const removeClientSubscription=(e,r,t)=>{if(exports.clients.has(e)&&exports.clients.get(e).has(r)){const s=exports.clients.get(e).get(r);s.subscriptions.delete(t);if(0===s.subscriptions.size){exports.clients.get(e).delete(r);0===exports.clients.get(e).size&&exports.clients.delete(e)}}};exports.removeClientSubscription=removeClientSubscription;const handleBroadcastMessage=async e=>{await processWebSocketMessage({...e,sendMessage:(r,t)=>{const s=e.route||"/api/user";exports.messageBroker.broadcastToRoute(s,{type:e.type,method:r,payload:t})}})};exports.handleBroadcastMessage=handleBroadcastMessage;const handleDirectClientMessage=async e=>{await processWebSocketMessage({...e,sendMessage:(r,t)=>{exports.messageBroker.sendToClient(e.clientId,{type:e.type,method:r,payload:t})}})};exports.handleDirectClientMessage=handleDirectClientMessage;const hasClients=e=>exports.clients.has(e)&&exports.clients.get(e).size>0;exports.hasClients=hasClients;const HEARTBEAT_INTERVAL=3e4;(0,heartbeat_1.startHeartbeat)(exports.clients,3e4);